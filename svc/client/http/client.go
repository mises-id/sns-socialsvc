// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 5f7d5bf015
// Version Date: 2021-11-26T09:27:01Z

// Package http provides an HTTP client for the Social service.
package http

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/gogo/protobuf/jsonpb"

	"github.com/go-kit/kit/endpoint"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/pkg/errors"

	// This Service
	pb "github.com/mises-id/sns-socialsvc/proto"
	"github.com/mises-id/sns-socialsvc/svc"
)

var (
	_ = endpoint.Chain
	_ = httptransport.NewClient
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = ioutil.NopCloser
	_ = io.EOF
)

// New returns a service backed by an HTTP server living at the remote
// instance. We expect instance to come from a service discovery system, so
// likely of the form "host:port".
func New(instance string, options ...httptransport.ClientOption) (pb.SocialServer, error) {

	if !strings.HasPrefix(instance, "http") {
		instance = "http://" + instance
	}
	u, err := url.Parse(instance)
	if err != nil {
		return nil, err
	}
	_ = u

	var SignInZeroEndpoint endpoint.Endpoint
	{
		SignInZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/signin/"),
			EncodeHTTPSignInZeroRequest,
			DecodeHTTPSignInResponse,
			options...,
		).Endpoint()
	}
	var FindUserZeroEndpoint endpoint.Endpoint
	{
		FindUserZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/"),
			EncodeHTTPFindUserZeroRequest,
			DecodeHTTPFindUserResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserProfileZeroEndpoint endpoint.Endpoint
	{
		UpdateUserProfileZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/profile/"),
			EncodeHTTPUpdateUserProfileZeroRequest,
			DecodeHTTPUpdateUserProfileResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserAvatarZeroEndpoint endpoint.Endpoint
	{
		UpdateUserAvatarZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/avatar/"),
			EncodeHTTPUpdateUserAvatarZeroRequest,
			DecodeHTTPUpdateUserAvatarResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserNameZeroEndpoint endpoint.Endpoint
	{
		UpdateUserNameZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/username/"),
			EncodeHTTPUpdateUserNameZeroRequest,
			DecodeHTTPUpdateUserNameResponse,
			options...,
		).Endpoint()
	}
	var CreateStatusZeroEndpoint endpoint.Endpoint
	{
		CreateStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/create/"),
			EncodeHTTPCreateStatusZeroRequest,
			DecodeHTTPCreateStatusResponse,
			options...,
		).Endpoint()
	}
	var UpdateStatusZeroEndpoint endpoint.Endpoint
	{
		UpdateStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/update/"),
			EncodeHTTPUpdateStatusZeroRequest,
			DecodeHTTPUpdateStatusResponse,
			options...,
		).Endpoint()
	}
	var DeleteStatusZeroEndpoint endpoint.Endpoint
	{
		DeleteStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/delete/"),
			EncodeHTTPDeleteStatusZeroRequest,
			DecodeHTTPDeleteStatusResponse,
			options...,
		).Endpoint()
	}
	var LikeStatusZeroEndpoint endpoint.Endpoint
	{
		LikeStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/like/"),
			EncodeHTTPLikeStatusZeroRequest,
			DecodeHTTPLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var UnLikeStatusZeroEndpoint endpoint.Endpoint
	{
		UnLikeStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/unlike/"),
			EncodeHTTPUnLikeStatusZeroRequest,
			DecodeHTTPUnLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var ListLikeStatusZeroEndpoint endpoint.Endpoint
	{
		ListLikeStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/like/list"),
			EncodeHTTPListLikeStatusZeroRequest,
			DecodeHTTPListLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var LikeNftAssetZeroEndpoint endpoint.Endpoint
	{
		LikeNftAssetZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/nft_asset/like/"),
			EncodeHTTPLikeNftAssetZeroRequest,
			DecodeHTTPLikeNftAssetResponse,
			options...,
		).Endpoint()
	}
	var UnlikeNftAssetZeroEndpoint endpoint.Endpoint
	{
		UnlikeNftAssetZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/nft_asset/unlike/"),
			EncodeHTTPUnlikeNftAssetZeroRequest,
			DecodeHTTPUnlikeNftAssetResponse,
			options...,
		).Endpoint()
	}
	var GetStatusZeroEndpoint endpoint.Endpoint
	{
		GetStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/"),
			EncodeHTTPGetStatusZeroRequest,
			DecodeHTTPGetStatusResponse,
			options...,
		).Endpoint()
	}
	var ListStatusZeroEndpoint endpoint.Endpoint
	{
		ListStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/list/"),
			EncodeHTTPListStatusZeroRequest,
			DecodeHTTPListStatusResponse,
			options...,
		).Endpoint()
	}
	var NewListStatusZeroEndpoint endpoint.Endpoint
	{
		NewListStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/new_list/"),
			EncodeHTTPNewListStatusZeroRequest,
			DecodeHTTPNewListStatusResponse,
			options...,
		).Endpoint()
	}
	var ListRecommendedZeroEndpoint endpoint.Endpoint
	{
		ListRecommendedZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/recommended/"),
			EncodeHTTPListRecommendedZeroRequest,
			DecodeHTTPListRecommendedResponse,
			options...,
		).Endpoint()
	}
	var ListUserTimelineZeroEndpoint endpoint.Endpoint
	{
		ListUserTimelineZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/timeline/"),
			EncodeHTTPListUserTimelineZeroRequest,
			DecodeHTTPListUserTimelineResponse,
			options...,
		).Endpoint()
	}
	var LatestFollowingZeroEndpoint endpoint.Endpoint
	{
		LatestFollowingZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/following/latest/"),
			EncodeHTTPLatestFollowingZeroRequest,
			DecodeHTTPLatestFollowingResponse,
			options...,
		).Endpoint()
	}
	var ListRelationshipZeroEndpoint endpoint.Endpoint
	{
		ListRelationshipZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/relation/list/"),
			EncodeHTTPListRelationshipZeroRequest,
			DecodeHTTPListRelationshipResponse,
			options...,
		).Endpoint()
	}
	var FollowZeroEndpoint endpoint.Endpoint
	{
		FollowZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/relation/follow/"),
			EncodeHTTPFollowZeroRequest,
			DecodeHTTPFollowResponse,
			options...,
		).Endpoint()
	}
	var UnFollowZeroEndpoint endpoint.Endpoint
	{
		UnFollowZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/relation/unfollow/"),
			EncodeHTTPUnFollowZeroRequest,
			DecodeHTTPUnFollowResponse,
			options...,
		).Endpoint()
	}
	var ListMessageZeroEndpoint endpoint.Endpoint
	{
		ListMessageZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/message/list/"),
			EncodeHTTPListMessageZeroRequest,
			DecodeHTTPListMessageResponse,
			options...,
		).Endpoint()
	}
	var ReadMessageZeroEndpoint endpoint.Endpoint
	{
		ReadMessageZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/message/read/"),
			EncodeHTTPReadMessageZeroRequest,
			DecodeHTTPReadMessageResponse,
			options...,
		).Endpoint()
	}
	var GetMessageSummaryZeroEndpoint endpoint.Endpoint
	{
		GetMessageSummaryZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/message/summary/"),
			EncodeHTTPGetMessageSummaryZeroRequest,
			DecodeHTTPGetMessageSummaryResponse,
			options...,
		).Endpoint()
	}
	var ListCommentZeroEndpoint endpoint.Endpoint
	{
		ListCommentZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/comment/list/"),
			EncodeHTTPListCommentZeroRequest,
			DecodeHTTPListCommentResponse,
			options...,
		).Endpoint()
	}
	var ListLikeZeroEndpoint endpoint.Endpoint
	{
		ListLikeZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/like/list/"),
			EncodeHTTPListLikeZeroRequest,
			DecodeHTTPListLikeResponse,
			options...,
		).Endpoint()
	}
	var GetCommentZeroEndpoint endpoint.Endpoint
	{
		GetCommentZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/comment/"),
			EncodeHTTPGetCommentZeroRequest,
			DecodeHTTPGetCommentResponse,
			options...,
		).Endpoint()
	}
	var NewRecommendStatusZeroEndpoint endpoint.Endpoint
	{
		NewRecommendStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/new_recommend/"),
			EncodeHTTPNewRecommendStatusZeroRequest,
			DecodeHTTPNewRecommendStatusResponse,
			options...,
		).Endpoint()
	}
	var CreateCommentZeroEndpoint endpoint.Endpoint
	{
		CreateCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/create/"),
			EncodeHTTPCreateCommentZeroRequest,
			DecodeHTTPCreateCommentResponse,
			options...,
		).Endpoint()
	}
	var DeleteCommentZeroEndpoint endpoint.Endpoint
	{
		DeleteCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/delete/"),
			EncodeHTTPDeleteCommentZeroRequest,
			DecodeHTTPDeleteCommentResponse,
			options...,
		).Endpoint()
	}
	var LikeCommentZeroEndpoint endpoint.Endpoint
	{
		LikeCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/like/"),
			EncodeHTTPLikeCommentZeroRequest,
			DecodeHTTPLikeCommentResponse,
			options...,
		).Endpoint()
	}
	var UnlikeCommentZeroEndpoint endpoint.Endpoint
	{
		UnlikeCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/unlike/"),
			EncodeHTTPUnlikeCommentZeroRequest,
			DecodeHTTPUnlikeCommentResponse,
			options...,
		).Endpoint()
	}
	var ListBlacklistZeroEndpoint endpoint.Endpoint
	{
		ListBlacklistZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/blacklist/list"),
			EncodeHTTPListBlacklistZeroRequest,
			DecodeHTTPListBlacklistResponse,
			options...,
		).Endpoint()
	}
	var CreateBlacklistZeroEndpoint endpoint.Endpoint
	{
		CreateBlacklistZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/blacklist/create/"),
			EncodeHTTPCreateBlacklistZeroRequest,
			DecodeHTTPCreateBlacklistResponse,
			options...,
		).Endpoint()
	}
	var DeleteBlacklistZeroEndpoint endpoint.Endpoint
	{
		DeleteBlacklistZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/blacklist/delete/"),
			EncodeHTTPDeleteBlacklistZeroRequest,
			DecodeHTTPDeleteBlacklistResponse,
			options...,
		).Endpoint()
	}
	var ShareTweetUrlZeroEndpoint endpoint.Endpoint
	{
		ShareTweetUrlZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/share/twitter/"),
			EncodeHTTPShareTweetUrlZeroRequest,
			DecodeHTTPShareTweetUrlResponse,
			options...,
		).Endpoint()
	}
	var TwitterAuthZeroEndpoint endpoint.Endpoint
	{
		TwitterAuthZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/twitter/auth/"),
			EncodeHTTPTwitterAuthZeroRequest,
			DecodeHTTPTwitterAuthResponse,
			options...,
		).Endpoint()
	}
	var AirdropTwitterZeroEndpoint endpoint.Endpoint
	{
		AirdropTwitterZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/airdrop/twitter/"),
			EncodeHTTPAirdropTwitterZeroRequest,
			DecodeHTTPAirdropTwitterResponse,
			options...,
		).Endpoint()
	}
	var AirdropChannelZeroEndpoint endpoint.Endpoint
	{
		AirdropChannelZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/airdrop/channel/"),
			EncodeHTTPAirdropChannelZeroRequest,
			DecodeHTTPAirdropChannelResponse,
			options...,
		).Endpoint()
	}
	var CreateAirdropTwitterZeroEndpoint endpoint.Endpoint
	{
		CreateAirdropTwitterZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/airdrop/create/"),
			EncodeHTTPCreateAirdropTwitterZeroRequest,
			DecodeHTTPCreateAirdropTwitterResponse,
			options...,
		).Endpoint()
	}
	var CreateChannelAirdropZeroEndpoint endpoint.Endpoint
	{
		CreateChannelAirdropZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/channel_airdrop/create/"),
			EncodeHTTPCreateChannelAirdropZeroRequest,
			DecodeHTTPCreateChannelAirdropResponse,
			options...,
		).Endpoint()
	}
	var UserToChainZeroEndpoint endpoint.Endpoint
	{
		UserToChainZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/to_chain/"),
			EncodeHTTPUserToChainZeroRequest,
			DecodeHTTPUserToChainResponse,
			options...,
		).Endpoint()
	}
	var ChannelInfoZeroEndpoint endpoint.Endpoint
	{
		ChannelInfoZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/channel/info/"),
			EncodeHTTPChannelInfoZeroRequest,
			DecodeHTTPChannelInfoResponse,
			options...,
		).Endpoint()
	}
	var PageChannelUserZeroEndpoint endpoint.Endpoint
	{
		PageChannelUserZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/channel_user/page/"),
			EncodeHTTPPageChannelUserZeroRequest,
			DecodeHTTPPageChannelUserResponse,
			options...,
		).Endpoint()
	}
	var GetChannelUserZeroEndpoint endpoint.Endpoint
	{
		GetChannelUserZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/channel_user/"),
			EncodeHTTPGetChannelUserZeroRequest,
			DecodeHTTPGetChannelUserResponse,
			options...,
		).Endpoint()
	}
	var GetOpenseaAssetZeroEndpoint endpoint.Endpoint
	{
		GetOpenseaAssetZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/opensea/single_asset/"),
			EncodeHTTPGetOpenseaAssetZeroRequest,
			DecodeHTTPGetOpenseaAssetResponse,
			options...,
		).Endpoint()
	}
	var ListOpenseaAssetZeroEndpoint endpoint.Endpoint
	{
		ListOpenseaAssetZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/opensea/assets/"),
			EncodeHTTPListOpenseaAssetZeroRequest,
			DecodeHTTPListOpenseaAssetResponse,
			options...,
		).Endpoint()
	}
	var GetOpenseaAssetContractZeroEndpoint endpoint.Endpoint
	{
		GetOpenseaAssetContractZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/opensea/asset_contract/"),
			EncodeHTTPGetOpenseaAssetContractZeroRequest,
			DecodeHTTPGetOpenseaAssetContractResponse,
			options...,
		).Endpoint()
	}
	var PageNftAssetZeroEndpoint endpoint.Endpoint
	{
		PageNftAssetZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/nft_asset/page/"),
			EncodeHTTPPageNftAssetZeroRequest,
			DecodeHTTPPageNftAssetResponse,
			options...,
		).Endpoint()
	}
	var GetNftAssetZeroEndpoint endpoint.Endpoint
	{
		GetNftAssetZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/nft_asset/get/"),
			EncodeHTTPGetNftAssetZeroRequest,
			DecodeHTTPGetNftAssetResponse,
			options...,
		).Endpoint()
	}
	var PageNftEventZeroEndpoint endpoint.Endpoint
	{
		PageNftEventZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/nft_event/page/"),
			EncodeHTTPPageNftEventZeroRequest,
			DecodeHTTPPageNftEventResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserConfigZeroEndpoint endpoint.Endpoint
	{
		UpdateUserConfigZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/config/"),
			EncodeHTTPUpdateUserConfigZeroRequest,
			DecodeHTTPUpdateUserConfigResponse,
			options...,
		).Endpoint()
	}
	var GetUserConfigZeroEndpoint endpoint.Endpoint
	{
		GetUserConfigZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/config/"),
			EncodeHTTPGetUserConfigZeroRequest,
			DecodeHTTPGetUserConfigResponse,
			options...,
		).Endpoint()
	}
	var UpdateOpenseaNftZeroEndpoint endpoint.Endpoint
	{
		UpdateOpenseaNftZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/nft/update/"),
			EncodeHTTPUpdateOpenseaNftZeroRequest,
			DecodeHTTPUpdateOpenseaNftResponse,
			options...,
		).Endpoint()
	}
	var GetTwitterAuthUrlZeroEndpoint endpoint.Endpoint
	{
		GetTwitterAuthUrlZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/twitter/auth_url/"),
			EncodeHTTPGetTwitterAuthUrlZeroRequest,
			DecodeHTTPGetTwitterAuthUrlResponse,
			options...,
		).Endpoint()
	}
	var GetAirdropInfoZeroEndpoint endpoint.Endpoint
	{
		GetAirdropInfoZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/airdrop/info/"),
			EncodeHTTPGetAirdropInfoZeroRequest,
			DecodeHTTPGetAirdropInfoResponse,
			options...,
		).Endpoint()
	}
	var TwitterCallbackZeroEndpoint endpoint.Endpoint
	{
		TwitterCallbackZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/twitter/callback/"),
			EncodeHTTPTwitterCallbackZeroRequest,
			DecodeHTTPTwitterCallbackResponse,
			options...,
		).Endpoint()
	}
	var TwitterFollowZeroEndpoint endpoint.Endpoint
	{
		TwitterFollowZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/twitter/follow/"),
			EncodeHTTPTwitterFollowZeroRequest,
			DecodeHTTPTwitterFollowResponse,
			options...,
		).Endpoint()
	}
	var ReceiveAirdropZeroEndpoint endpoint.Endpoint
	{
		ReceiveAirdropZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/airdrop/receive/"),
			EncodeHTTPReceiveAirdropZeroRequest,
			DecodeHTTPReceiveAirdropResponse,
			options...,
		).Endpoint()
	}

	return svc.Endpoints{
		SignInEndpoint:                  SignInZeroEndpoint,
		FindUserEndpoint:                FindUserZeroEndpoint,
		UpdateUserProfileEndpoint:       UpdateUserProfileZeroEndpoint,
		UpdateUserAvatarEndpoint:        UpdateUserAvatarZeroEndpoint,
		UpdateUserNameEndpoint:          UpdateUserNameZeroEndpoint,
		CreateStatusEndpoint:            CreateStatusZeroEndpoint,
		UpdateStatusEndpoint:            UpdateStatusZeroEndpoint,
		DeleteStatusEndpoint:            DeleteStatusZeroEndpoint,
		LikeStatusEndpoint:              LikeStatusZeroEndpoint,
		UnLikeStatusEndpoint:            UnLikeStatusZeroEndpoint,
		ListLikeStatusEndpoint:          ListLikeStatusZeroEndpoint,
		LikeNftAssetEndpoint:            LikeNftAssetZeroEndpoint,
		UnlikeNftAssetEndpoint:          UnlikeNftAssetZeroEndpoint,
		GetStatusEndpoint:               GetStatusZeroEndpoint,
		ListStatusEndpoint:              ListStatusZeroEndpoint,
		NewListStatusEndpoint:           NewListStatusZeroEndpoint,
		ListRecommendedEndpoint:         ListRecommendedZeroEndpoint,
		ListUserTimelineEndpoint:        ListUserTimelineZeroEndpoint,
		LatestFollowingEndpoint:         LatestFollowingZeroEndpoint,
		ListRelationshipEndpoint:        ListRelationshipZeroEndpoint,
		FollowEndpoint:                  FollowZeroEndpoint,
		UnFollowEndpoint:                UnFollowZeroEndpoint,
		ListMessageEndpoint:             ListMessageZeroEndpoint,
		ReadMessageEndpoint:             ReadMessageZeroEndpoint,
		GetMessageSummaryEndpoint:       GetMessageSummaryZeroEndpoint,
		ListCommentEndpoint:             ListCommentZeroEndpoint,
		ListLikeEndpoint:                ListLikeZeroEndpoint,
		GetCommentEndpoint:              GetCommentZeroEndpoint,
		NewRecommendStatusEndpoint:      NewRecommendStatusZeroEndpoint,
		CreateCommentEndpoint:           CreateCommentZeroEndpoint,
		DeleteCommentEndpoint:           DeleteCommentZeroEndpoint,
		LikeCommentEndpoint:             LikeCommentZeroEndpoint,
		UnlikeCommentEndpoint:           UnlikeCommentZeroEndpoint,
		ListBlacklistEndpoint:           ListBlacklistZeroEndpoint,
		CreateBlacklistEndpoint:         CreateBlacklistZeroEndpoint,
		DeleteBlacklistEndpoint:         DeleteBlacklistZeroEndpoint,
		ShareTweetUrlEndpoint:           ShareTweetUrlZeroEndpoint,
		TwitterAuthEndpoint:             TwitterAuthZeroEndpoint,
		AirdropTwitterEndpoint:          AirdropTwitterZeroEndpoint,
		AirdropChannelEndpoint:          AirdropChannelZeroEndpoint,
		CreateAirdropTwitterEndpoint:    CreateAirdropTwitterZeroEndpoint,
		CreateChannelAirdropEndpoint:    CreateChannelAirdropZeroEndpoint,
		UserToChainEndpoint:             UserToChainZeroEndpoint,
		ChannelInfoEndpoint:             ChannelInfoZeroEndpoint,
		PageChannelUserEndpoint:         PageChannelUserZeroEndpoint,
		GetChannelUserEndpoint:          GetChannelUserZeroEndpoint,
		GetOpenseaAssetEndpoint:         GetOpenseaAssetZeroEndpoint,
		ListOpenseaAssetEndpoint:        ListOpenseaAssetZeroEndpoint,
		GetOpenseaAssetContractEndpoint: GetOpenseaAssetContractZeroEndpoint,
		PageNftAssetEndpoint:            PageNftAssetZeroEndpoint,
		GetNftAssetEndpoint:             GetNftAssetZeroEndpoint,
		PageNftEventEndpoint:            PageNftEventZeroEndpoint,
		UpdateUserConfigEndpoint:        UpdateUserConfigZeroEndpoint,
		GetUserConfigEndpoint:           GetUserConfigZeroEndpoint,
		UpdateOpenseaNftEndpoint:        UpdateOpenseaNftZeroEndpoint,
		GetTwitterAuthUrlEndpoint:       GetTwitterAuthUrlZeroEndpoint,
		GetAirdropInfoEndpoint:          GetAirdropInfoZeroEndpoint,
		TwitterCallbackEndpoint:         TwitterCallbackZeroEndpoint,
		TwitterFollowEndpoint:           TwitterFollowZeroEndpoint,
		ReceiveAirdropEndpoint:          ReceiveAirdropZeroEndpoint,
	}, nil
}

func copyURL(base *url.URL, path string) *url.URL {
	next := *base
	next.Path = path
	return &next
}

// CtxValuesToSend configures the http client to pull the specified keys out of
// the context and add them to the http request as headers.  Note that keys
// will have net/http.CanonicalHeaderKey called on them before being send over
// the wire and that is the form they will be available in the server context.
func CtxValuesToSend(keys ...string) httptransport.ClientOption {
	return httptransport.ClientBefore(func(ctx context.Context, r *http.Request) context.Context {
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				r.Header.Set(k, v)
			}
		}
		return ctx
	})
}

// HTTP Client Decode

// DecodeHTTPSignInResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SignInResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPSignInResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SignInResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPFindUserResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded FindUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPFindUserResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.FindUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserProfileResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserProfileResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserAvatarResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserAvatarResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserNameResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserNameResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListLikeResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListLikeResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLikeNftAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLikeNftAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnlikeNftAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnlikeNftAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPNewListStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded NewListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPNewListStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.NewListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListRecommendedResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListRecommendedResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListUserTimelineResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListUserTimelineResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLatestFollowingResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded LatestFollowingResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLatestFollowingResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.LatestFollowingResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListRelationshipResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListRelationshipResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListRelationshipResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListRelationshipResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPFollowResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPFollowResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnFollowResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnFollowResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListMessageResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListMessageResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListMessageResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListMessageResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPReadMessageResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPReadMessageResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetMessageSummaryResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded MessageSummaryResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetMessageSummaryResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.MessageSummaryResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListCommentResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListCommentResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListLikeResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListLikeUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListLikeResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListLikeUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetCommentResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetCommentResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPNewRecommendStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded NewRecommendStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPNewRecommendStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.NewRecommendStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateCommentResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateCommentResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLikeCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLikeCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnlikeCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnlikeCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListBlacklistResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListBlacklistResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPShareTweetUrlResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ShareTweetUrlResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPShareTweetUrlResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ShareTweetUrlResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPTwitterAuthResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded TwitterAuthResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPTwitterAuthResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.TwitterAuthResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPAirdropTwitterResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded AirdropTwitterResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPAirdropTwitterResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.AirdropTwitterResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPAirdropChannelResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded AirdropChannelResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPAirdropChannelResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.AirdropChannelResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateAirdropTwitterResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateAirdropTwitterResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateAirdropTwitterResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateAirdropTwitterResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateChannelAirdropResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateChannelAirdropResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateChannelAirdropResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateChannelAirdropResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUserToChainResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UserToChainResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUserToChainResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UserToChainResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPChannelInfoResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ChannelInfoResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPChannelInfoResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ChannelInfoResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPPageChannelUserResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded PageChannelUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPPageChannelUserResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.PageChannelUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetChannelUserResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetChannelUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetChannelUserResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetChannelUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetOpenseaAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetOpenseaAssetResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetOpenseaAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetOpenseaAssetResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListOpenseaAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListOpenseaAssetResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListOpenseaAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListOpenseaAssetResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetOpenseaAssetContractResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetOpenseaAssetContractResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetOpenseaAssetContractResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetOpenseaAssetContractResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPPageNftAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded PageNftAssetResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPPageNftAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.PageNftAssetResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetNftAssetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetNftAssetResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetNftAssetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetNftAssetResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPPageNftEventResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded PageNftEventResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPPageNftEventResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.PageNftEventResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserConfigResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserConfigResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserConfigResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserConfigResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetUserConfigResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetUserConfigResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetUserConfigResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetUserConfigResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateOpenseaNftResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateOpenseaNftResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateOpenseaNftResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateOpenseaNftResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetTwitterAuthUrlResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetTwitterAuthUrlResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetTwitterAuthUrlResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetTwitterAuthUrlResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetAirdropInfoResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetAirdropInfoResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetAirdropInfoResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetAirdropInfoResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPTwitterCallbackResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded TwitterCallbackResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPTwitterCallbackResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.TwitterCallbackResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPTwitterFollowResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded TwitterFollowResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPTwitterFollowResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.TwitterFollowResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPReceiveAirdropResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ReceiveAirdropResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPReceiveAirdropResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ReceiveAirdropResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// HTTP Client Encode

// EncodeHTTPSignInZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a signin request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPSignInZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.SignInRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"signin",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("auth", fmt.Sprint(req.Auth))

	values.Add("referrer", fmt.Sprint(req.Referrer))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPSignInOneRequest is a transport/http.EncodeRequestFunc
// that encodes a signin request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPSignInOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.SignInRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"signin",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("auth", fmt.Sprint(req.Auth))

	values.Add("referrer", fmt.Sprint(req.Referrer))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFindUserZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a finduser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFindUserZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FindUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFindUserOneRequest is a transport/http.EncodeRequestFunc
// that encodes a finduser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFindUserOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FindUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUpdateUserProfileZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserprofile request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserProfileZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserProfileRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"profile",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserProfileRequest)

	toRet.Uid = req.Uid

	toRet.Gender = req.Gender

	toRet.Mobile = req.Mobile

	toRet.Email = req.Email

	toRet.Address = req.Address

	toRet.Intro = req.Intro

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserProfileOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserprofile request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserProfileOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserProfileRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"profile",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserProfileRequest)

	toRet.Uid = req.Uid

	toRet.Gender = req.Gender

	toRet.Mobile = req.Mobile

	toRet.Email = req.Email

	toRet.Address = req.Address

	toRet.Intro = req.Intro

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserAvatarZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuseravatar request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserAvatarZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserAvatarRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"avatar",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserAvatarRequest)

	toRet.Uid = req.Uid

	toRet.AttachmentPath = req.AttachmentPath

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserAvatarOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuseravatar request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserAvatarOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserAvatarRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"avatar",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserAvatarRequest)

	toRet.Uid = req.Uid

	toRet.AttachmentPath = req.AttachmentPath

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserNameZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateusername request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserNameZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserNameRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"username",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserNameRequest)

	toRet.Uid = req.Uid

	toRet.Username = req.Username

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserNameOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateusername request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserNameOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserNameRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"username",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserNameRequest)

	toRet.Uid = req.Uid

	toRet.Username = req.Username

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusType = req.StatusType

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.Meta = req.Meta

	toRet.FromType = req.FromType

	toRet.Images = req.Images

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusType = req.StatusType

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.Meta = req.Meta

	toRet.FromType = req.FromType

	toRet.Images = req.Images

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updatestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"update",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updatestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"update",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deletestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deletestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a likestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a likestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"unlike",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"unlike",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPLikeNftAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a likenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeNftAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"like",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeNftAssetRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeNftAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a likenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeNftAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"like",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeNftAssetRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeNftAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeNftAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"unlike",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeNftAssetRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeNftAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeNftAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"unlike",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeNftAssetRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPGetStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("statusid", fmt.Sprint(req.Statusid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("statusid", fmt.Sprint(req.Statusid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a liststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a liststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewListStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a newliststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewListStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values["ids"] = req.Ids

	values.Add("list_num", fmt.Sprint(req.ListNum))

	values["from_types"] = req.FromTypes

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewListStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a newliststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewListStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values["ids"] = req.Ids

	values.Add("list_num", fmt.Sprint(req.ListNum))

	values["from_types"] = req.FromTypes

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRecommendedZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listrecommended request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRecommendedZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"recommended",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRecommendedOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listrecommended request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRecommendedOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"recommended",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListUserTimelineZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listusertimeline request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListUserTimelineZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"timeline",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListUserTimelineOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listusertimeline request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListUserTimelineOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"timeline",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPLatestFollowingZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a latestfollowing request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLatestFollowingZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LatestFollowingRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"following",
		"latest",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPLatestFollowingOneRequest is a transport/http.EncodeRequestFunc
// that encodes a latestfollowing request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLatestFollowingOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LatestFollowingRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"following",
		"latest",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRelationshipZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listrelationship request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRelationshipZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListRelationshipRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("relation_type", fmt.Sprint(req.RelationType))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRelationshipOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listrelationship request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRelationshipOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListRelationshipRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("relation_type", fmt.Sprint(req.RelationType))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFollowZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a follow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFollowZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"follow",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.FollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPFollowOneRequest is a transport/http.EncodeRequestFunc
// that encodes a follow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFollowOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"follow",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.FollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnFollowZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnFollowZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"unfollow",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnFollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnFollowOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnFollowOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"unfollow",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnFollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListMessageZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListMessageZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("state", fmt.Sprint(req.State))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListMessageOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListMessageOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("state", fmt.Sprint(req.State))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPReadMessageZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a readmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReadMessageZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReadMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"read",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.ReadMessageRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.LatestID = req.LatestID

	toRet.Ids = req.Ids

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPReadMessageOneRequest is a transport/http.EncodeRequestFunc
// that encodes a readmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReadMessageOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReadMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"read",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.ReadMessageRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.LatestID = req.LatestID

	toRet.Ids = req.Ids

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPGetMessageSummaryZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getmessagesummary request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetMessageSummaryZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetMessageSummaryRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"summary",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetMessageSummaryOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getmessagesummary request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetMessageSummaryOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetMessageSummaryRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"summary",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("status_id", fmt.Sprint(req.StatusId))

	values.Add("topic_id", fmt.Sprint(req.TopicId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("status_id", fmt.Sprint(req.StatusId))

	values.Add("topic_id", fmt.Sprint(req.TopicId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListLikeZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listlike request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"like",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("targer_id", fmt.Sprint(req.TargerId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListLikeOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listlike request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"like",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("targer_id", fmt.Sprint(req.TargerId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("comment_id", fmt.Sprint(req.CommentId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("comment_id", fmt.Sprint(req.CommentId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewRecommendStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a newrecommendstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewRecommendStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewRecommendStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_recommend",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("last_recommend_time", fmt.Sprint(req.LastRecommendTime))

	values.Add("last_common_time", fmt.Sprint(req.LastCommonTime))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewRecommendStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a newrecommendstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewRecommendStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewRecommendStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_recommend",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("last_recommend_time", fmt.Sprint(req.LastRecommendTime))

	values.Add("last_common_time", fmt.Sprint(req.LastCommonTime))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.NftAssetId = req.NftAssetId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deletecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Id = req.Id

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deletecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Id = req.Id

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a likecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"like",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a likecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"like",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnlikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"unlike",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnlikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnlikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"unlike",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnlikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deleteblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deleteblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPShareTweetUrlZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a sharetweeturl request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPShareTweetUrlZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ShareTweetUrlRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"share",
		"twitter",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPShareTweetUrlOneRequest is a transport/http.EncodeRequestFunc
// that encodes a sharetweeturl request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPShareTweetUrlOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ShareTweetUrlRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"share",
		"twitter",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterAuthZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a twitterauth request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterAuthZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterAuthRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"auth",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterAuthOneRequest is a transport/http.EncodeRequestFunc
// that encodes a twitterauth request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterAuthOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterAuthRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"auth",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPAirdropTwitterZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a airdroptwitter request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPAirdropTwitterZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.AirdropTwitterRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"twitter",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPAirdropTwitterOneRequest is a transport/http.EncodeRequestFunc
// that encodes a airdroptwitter request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPAirdropTwitterOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.AirdropTwitterRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"twitter",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPAirdropChannelZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a airdropchannel request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPAirdropChannelZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.AirdropChannelRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"channel",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPAirdropChannelOneRequest is a transport/http.EncodeRequestFunc
// that encodes a airdropchannel request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPAirdropChannelOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.AirdropChannelRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"channel",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateAirdropTwitterZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createairdroptwitter request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateAirdropTwitterZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateAirdropTwitterRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateAirdropTwitterOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createairdroptwitter request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateAirdropTwitterOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateAirdropTwitterRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateChannelAirdropZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createchannelairdrop request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateChannelAirdropZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateChannelAirdropRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_airdrop",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateChannelAirdropOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createchannelairdrop request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateChannelAirdropOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateChannelAirdropRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_airdrop",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUserToChainZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a usertochain request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUserToChainZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UserToChainRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"to_chain",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUserToChainOneRequest is a transport/http.EncodeRequestFunc
// that encodes a usertochain request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUserToChainOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UserToChainRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"to_chain",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPChannelInfoZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a channelinfo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPChannelInfoZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ChannelInfoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel",
		"info",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	values.Add("type", fmt.Sprint(req.Type))

	values.Add("medium", fmt.Sprint(req.Medium))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPChannelInfoOneRequest is a transport/http.EncodeRequestFunc
// that encodes a channelinfo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPChannelInfoOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ChannelInfoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel",
		"info",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	values.Add("type", fmt.Sprint(req.Type))

	values.Add("medium", fmt.Sprint(req.Medium))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageChannelUserZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a pagechanneluser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageChannelUserZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageChannelUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_user",
		"page",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageChannelUserOneRequest is a transport/http.EncodeRequestFunc
// that encodes a pagechanneluser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageChannelUserOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageChannelUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_user",
		"page",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetChannelUserZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getchanneluser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetChannelUserZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetChannelUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_user",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetChannelUserOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getchanneluser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetChannelUserOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetChannelUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"channel_user",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("misesid", fmt.Sprint(req.Misesid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetOpenseaAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getopenseaasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetOpenseaAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetOpenseaAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"single_asset",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("asset_contract_address", fmt.Sprint(req.AssetContractAddress))

	values.Add("token_id", fmt.Sprint(req.TokenId))

	values.Add("account_address", fmt.Sprint(req.AccountAddress))

	values.Add("include_orders", fmt.Sprint(req.IncludeOrders))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetOpenseaAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getopenseaasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetOpenseaAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetOpenseaAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"single_asset",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("asset_contract_address", fmt.Sprint(req.AssetContractAddress))

	values.Add("token_id", fmt.Sprint(req.TokenId))

	values.Add("account_address", fmt.Sprint(req.AccountAddress))

	values.Add("include_orders", fmt.Sprint(req.IncludeOrders))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListOpenseaAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listopenseaasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListOpenseaAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListOpenseaAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"assets",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("owner", fmt.Sprint(req.Owner))

	values.Add("limit", fmt.Sprint(req.Limit))

	values.Add("cursor", fmt.Sprint(req.Cursor))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListOpenseaAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listopenseaasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListOpenseaAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListOpenseaAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"assets",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("owner", fmt.Sprint(req.Owner))

	values.Add("limit", fmt.Sprint(req.Limit))

	values.Add("cursor", fmt.Sprint(req.Cursor))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetOpenseaAssetContractZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getopenseaassetcontract request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetOpenseaAssetContractZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetOpenseaAssetContractRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"asset_contract",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("asset_contract_address", fmt.Sprint(req.AssetContractAddress))

	values.Add("token_id", fmt.Sprint(req.TokenId))

	values.Add("account_address", fmt.Sprint(req.AccountAddress))

	values.Add("include_orders", fmt.Sprint(req.IncludeOrders))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetOpenseaAssetContractOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getopenseaassetcontract request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetOpenseaAssetContractOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetOpenseaAssetContractRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"opensea",
		"asset_contract",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("asset_contract_address", fmt.Sprint(req.AssetContractAddress))

	values.Add("token_id", fmt.Sprint(req.TokenId))

	values.Add("account_address", fmt.Sprint(req.AccountAddress))

	values.Add("include_orders", fmt.Sprint(req.IncludeOrders))

	values.Add("network", fmt.Sprint(req.Network))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageNftAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a pagenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageNftAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"page",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	values.Add("sort_by", fmt.Sprint(req.SortBy))

	values.Add("scene", fmt.Sprint(req.Scene))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageNftAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a pagenftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageNftAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"page",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	values.Add("sort_by", fmt.Sprint(req.SortBy))

	values.Add("scene", fmt.Sprint(req.Scene))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetNftAssetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getnftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetNftAssetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"get",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetNftAssetOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getnftasset request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetNftAssetOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetNftAssetRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_asset",
		"get",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageNftEventZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a pagenftevent request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageNftEventZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageNftEventRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_event",
		"page",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPPageNftEventOneRequest is a transport/http.EncodeRequestFunc
// that encodes a pagenftevent request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPPageNftEventOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.PageNftEventRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft_event",
		"page",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("nft_asset_id", fmt.Sprint(req.NftAssetId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUpdateUserConfigZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserconfig request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserConfigZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserConfigRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"config",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserConfigRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftState = req.NftState

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserConfigOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserconfig request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserConfigOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserConfigRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"config",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserConfigRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.NftState = req.NftState

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPGetUserConfigZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getuserconfig request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetUserConfigZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetUserConfigRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"config",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetUserConfigOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getuserconfig request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetUserConfigOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetUserConfigRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"config",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUpdateOpenseaNftZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateopenseanft request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateOpenseaNftZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateOpenseaNftRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft",
		"update",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUpdateOpenseaNftOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateopenseanft request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateOpenseaNftOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateOpenseaNftRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"nft",
		"update",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetTwitterAuthUrlZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a gettwitterauthurl request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetTwitterAuthUrlZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetTwitterAuthUrlRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"auth_url",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetTwitterAuthUrlOneRequest is a transport/http.EncodeRequestFunc
// that encodes a gettwitterauthurl request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetTwitterAuthUrlOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetTwitterAuthUrlRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"auth_url",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetAirdropInfoZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getairdropinfo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetAirdropInfoZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetAirdropInfoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"info",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetAirdropInfoOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getairdropinfo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetAirdropInfoOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetAirdropInfoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"info",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterCallbackZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a twittercallback request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterCallbackZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterCallbackRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"callback",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("oauth_token", fmt.Sprint(req.OauthToken))

	values.Add("oauth_verifier", fmt.Sprint(req.OauthVerifier))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterCallbackOneRequest is a transport/http.EncodeRequestFunc
// that encodes a twittercallback request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterCallbackOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterCallbackRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"callback",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("oauth_token", fmt.Sprint(req.OauthToken))

	values.Add("oauth_verifier", fmt.Sprint(req.OauthVerifier))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterFollowZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a twitterfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterFollowZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"follow",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPTwitterFollowOneRequest is a transport/http.EncodeRequestFunc
// that encodes a twitterfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPTwitterFollowOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.TwitterFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"twitter",
		"follow",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPReceiveAirdropZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a receiveairdrop request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReceiveAirdropZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReceiveAirdropRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"receive",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("tweet", fmt.Sprint(req.Tweet))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPReceiveAirdropOneRequest is a transport/http.EncodeRequestFunc
// that encodes a receiveairdrop request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReceiveAirdropOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReceiveAirdropRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"airdrop",
		"receive",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("tweet", fmt.Sprint(req.Tweet))

	r.URL.RawQuery = values.Encode()
	return nil
}

func errorDecoder(buf []byte) error {
	var w errorWrapper
	if err := json.Unmarshal(buf, &w); err != nil {
		const size = 8196
		if len(buf) > size {
			buf = buf[:size]
		}
		return fmt.Errorf("response body '%s': cannot parse non-json request body", buf)
	}

	return errors.New(w.Error)
}

type errorWrapper struct {
	Error string `json:"error"`
}
