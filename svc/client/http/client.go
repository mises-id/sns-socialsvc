// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 5f7d5bf015
// Version Date: 2021-11-26T09:27:01Z

// Package http provides an HTTP client for the Social service.
package http

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/gogo/protobuf/jsonpb"

	"github.com/go-kit/kit/endpoint"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/pkg/errors"

	// This Service
	pb "github.com/mises-id/sns-socialsvc/proto"
	"github.com/mises-id/sns-socialsvc/svc"
)

var (
	_ = endpoint.Chain
	_ = httptransport.NewClient
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = ioutil.NopCloser
	_ = io.EOF
)

// New returns a service backed by an HTTP server living at the remote
// instance. We expect instance to come from a service discovery system, so
// likely of the form "host:port".
func New(instance string, options ...httptransport.ClientOption) (pb.SocialServer, error) {

	if !strings.HasPrefix(instance, "http") {
		instance = "http://" + instance
	}
	u, err := url.Parse(instance)
	if err != nil {
		return nil, err
	}
	_ = u

	var SignInZeroEndpoint endpoint.Endpoint
	{
		SignInZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/signin/"),
			EncodeHTTPSignInZeroRequest,
			DecodeHTTPSignInResponse,
			options...,
		).Endpoint()
	}
	var FindUserZeroEndpoint endpoint.Endpoint
	{
		FindUserZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/"),
			EncodeHTTPFindUserZeroRequest,
			DecodeHTTPFindUserResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserProfileZeroEndpoint endpoint.Endpoint
	{
		UpdateUserProfileZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/profile/"),
			EncodeHTTPUpdateUserProfileZeroRequest,
			DecodeHTTPUpdateUserProfileResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserAvatarZeroEndpoint endpoint.Endpoint
	{
		UpdateUserAvatarZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/avatar/"),
			EncodeHTTPUpdateUserAvatarZeroRequest,
			DecodeHTTPUpdateUserAvatarResponse,
			options...,
		).Endpoint()
	}
	var UpdateUserNameZeroEndpoint endpoint.Endpoint
	{
		UpdateUserNameZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/username/"),
			EncodeHTTPUpdateUserNameZeroRequest,
			DecodeHTTPUpdateUserNameResponse,
			options...,
		).Endpoint()
	}
	var CreateStatusZeroEndpoint endpoint.Endpoint
	{
		CreateStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/create/"),
			EncodeHTTPCreateStatusZeroRequest,
			DecodeHTTPCreateStatusResponse,
			options...,
		).Endpoint()
	}
	var UpdateStatusZeroEndpoint endpoint.Endpoint
	{
		UpdateStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/update/"),
			EncodeHTTPUpdateStatusZeroRequest,
			DecodeHTTPUpdateStatusResponse,
			options...,
		).Endpoint()
	}
	var DeleteStatusZeroEndpoint endpoint.Endpoint
	{
		DeleteStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/delete/"),
			EncodeHTTPDeleteStatusZeroRequest,
			DecodeHTTPDeleteStatusResponse,
			options...,
		).Endpoint()
	}
	var LikeStatusZeroEndpoint endpoint.Endpoint
	{
		LikeStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/like/"),
			EncodeHTTPLikeStatusZeroRequest,
			DecodeHTTPLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var UnLikeStatusZeroEndpoint endpoint.Endpoint
	{
		UnLikeStatusZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/status/unlike/"),
			EncodeHTTPUnLikeStatusZeroRequest,
			DecodeHTTPUnLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var ListLikeStatusZeroEndpoint endpoint.Endpoint
	{
		ListLikeStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/like/list"),
			EncodeHTTPListLikeStatusZeroRequest,
			DecodeHTTPListLikeStatusResponse,
			options...,
		).Endpoint()
	}
	var GetStatusZeroEndpoint endpoint.Endpoint
	{
		GetStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/"),
			EncodeHTTPGetStatusZeroRequest,
			DecodeHTTPGetStatusResponse,
			options...,
		).Endpoint()
	}
	var ListStatusZeroEndpoint endpoint.Endpoint
	{
		ListStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/list/"),
			EncodeHTTPListStatusZeroRequest,
			DecodeHTTPListStatusResponse,
			options...,
		).Endpoint()
	}
	var ListRecommendedZeroEndpoint endpoint.Endpoint
	{
		ListRecommendedZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/recommended/"),
			EncodeHTTPListRecommendedZeroRequest,
			DecodeHTTPListRecommendedResponse,
			options...,
		).Endpoint()
	}
	var ListUserTimelineZeroEndpoint endpoint.Endpoint
	{
		ListUserTimelineZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/timeline/"),
			EncodeHTTPListUserTimelineZeroRequest,
			DecodeHTTPListUserTimelineResponse,
			options...,
		).Endpoint()
	}
	var LatestFollowingZeroEndpoint endpoint.Endpoint
	{
		LatestFollowingZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/following/latest/"),
			EncodeHTTPLatestFollowingZeroRequest,
			DecodeHTTPLatestFollowingResponse,
			options...,
		).Endpoint()
	}
	var ListRelationshipZeroEndpoint endpoint.Endpoint
	{
		ListRelationshipZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/relation/list/"),
			EncodeHTTPListRelationshipZeroRequest,
			DecodeHTTPListRelationshipResponse,
			options...,
		).Endpoint()
	}
	var FollowZeroEndpoint endpoint.Endpoint
	{
		FollowZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/relation/follow/"),
			EncodeHTTPFollowZeroRequest,
			DecodeHTTPFollowResponse,
			options...,
		).Endpoint()
	}
	var UnFollowZeroEndpoint endpoint.Endpoint
	{
		UnFollowZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/relation/unfollow/"),
			EncodeHTTPUnFollowZeroRequest,
			DecodeHTTPUnFollowResponse,
			options...,
		).Endpoint()
	}
	var ListMessageZeroEndpoint endpoint.Endpoint
	{
		ListMessageZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/message/list/"),
			EncodeHTTPListMessageZeroRequest,
			DecodeHTTPListMessageResponse,
			options...,
		).Endpoint()
	}
	var ReadMessageZeroEndpoint endpoint.Endpoint
	{
		ReadMessageZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/message/read/"),
			EncodeHTTPReadMessageZeroRequest,
			DecodeHTTPReadMessageResponse,
			options...,
		).Endpoint()
	}
	var GetMessageSummaryZeroEndpoint endpoint.Endpoint
	{
		GetMessageSummaryZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/message/summary/"),
			EncodeHTTPGetMessageSummaryZeroRequest,
			DecodeHTTPGetMessageSummaryResponse,
			options...,
		).Endpoint()
	}
	var ListCommentZeroEndpoint endpoint.Endpoint
	{
		ListCommentZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/comment/list/"),
			EncodeHTTPListCommentZeroRequest,
			DecodeHTTPListCommentResponse,
			options...,
		).Endpoint()
	}
	var NewRecommendStatusZeroEndpoint endpoint.Endpoint
	{
		NewRecommendStatusZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/status/new_recommend/"),
			EncodeHTTPNewRecommendStatusZeroRequest,
			DecodeHTTPNewRecommendStatusResponse,
			options...,
		).Endpoint()
	}
	var CreateCommentZeroEndpoint endpoint.Endpoint
	{
		CreateCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/create/"),
			EncodeHTTPCreateCommentZeroRequest,
			DecodeHTTPCreateCommentResponse,
			options...,
		).Endpoint()
	}
	var DeleteCommentZeroEndpoint endpoint.Endpoint
	{
		DeleteCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/delete/"),
			EncodeHTTPDeleteCommentZeroRequest,
			DecodeHTTPDeleteCommentResponse,
			options...,
		).Endpoint()
	}
	var LikeCommentZeroEndpoint endpoint.Endpoint
	{
		LikeCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/like/"),
			EncodeHTTPLikeCommentZeroRequest,
			DecodeHTTPLikeCommentResponse,
			options...,
		).Endpoint()
	}
	var UnlikeCommentZeroEndpoint endpoint.Endpoint
	{
		UnlikeCommentZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/comment/unlike/"),
			EncodeHTTPUnlikeCommentZeroRequest,
			DecodeHTTPUnlikeCommentResponse,
			options...,
		).Endpoint()
	}
	var ListBlacklistZeroEndpoint endpoint.Endpoint
	{
		ListBlacklistZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/user/blacklist/list"),
			EncodeHTTPListBlacklistZeroRequest,
			DecodeHTTPListBlacklistResponse,
			options...,
		).Endpoint()
	}
	var CreateBlacklistZeroEndpoint endpoint.Endpoint
	{
		CreateBlacklistZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/blacklist/create/"),
			EncodeHTTPCreateBlacklistZeroRequest,
			DecodeHTTPCreateBlacklistResponse,
			options...,
		).Endpoint()
	}
	var DeleteBlacklistZeroEndpoint endpoint.Endpoint
	{
		DeleteBlacklistZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/user/blacklist/delete/"),
			EncodeHTTPDeleteBlacklistZeroRequest,
			DecodeHTTPDeleteBlacklistResponse,
			options...,
		).Endpoint()
	}

	return svc.Endpoints{
		SignInEndpoint:             SignInZeroEndpoint,
		FindUserEndpoint:           FindUserZeroEndpoint,
		UpdateUserProfileEndpoint:  UpdateUserProfileZeroEndpoint,
		UpdateUserAvatarEndpoint:   UpdateUserAvatarZeroEndpoint,
		UpdateUserNameEndpoint:     UpdateUserNameZeroEndpoint,
		CreateStatusEndpoint:       CreateStatusZeroEndpoint,
		UpdateStatusEndpoint:       UpdateStatusZeroEndpoint,
		DeleteStatusEndpoint:       DeleteStatusZeroEndpoint,
		LikeStatusEndpoint:         LikeStatusZeroEndpoint,
		UnLikeStatusEndpoint:       UnLikeStatusZeroEndpoint,
		ListLikeStatusEndpoint:     ListLikeStatusZeroEndpoint,
		GetStatusEndpoint:          GetStatusZeroEndpoint,
		ListStatusEndpoint:         ListStatusZeroEndpoint,
		ListRecommendedEndpoint:    ListRecommendedZeroEndpoint,
		ListUserTimelineEndpoint:   ListUserTimelineZeroEndpoint,
		LatestFollowingEndpoint:    LatestFollowingZeroEndpoint,
		ListRelationshipEndpoint:   ListRelationshipZeroEndpoint,
		FollowEndpoint:             FollowZeroEndpoint,
		UnFollowEndpoint:           UnFollowZeroEndpoint,
		ListMessageEndpoint:        ListMessageZeroEndpoint,
		ReadMessageEndpoint:        ReadMessageZeroEndpoint,
		GetMessageSummaryEndpoint:  GetMessageSummaryZeroEndpoint,
		ListCommentEndpoint:        ListCommentZeroEndpoint,
		NewRecommendStatusEndpoint: NewRecommendStatusZeroEndpoint,
		CreateCommentEndpoint:      CreateCommentZeroEndpoint,
		DeleteCommentEndpoint:      DeleteCommentZeroEndpoint,
		LikeCommentEndpoint:        LikeCommentZeroEndpoint,
		UnlikeCommentEndpoint:      UnlikeCommentZeroEndpoint,
		ListBlacklistEndpoint:      ListBlacklistZeroEndpoint,
		CreateBlacklistEndpoint:    CreateBlacklistZeroEndpoint,
		DeleteBlacklistEndpoint:    DeleteBlacklistZeroEndpoint,
	}, nil
}

func copyURL(base *url.URL, path string) *url.URL {
	next := *base
	next.Path = path
	return &next
}

// CtxValuesToSend configures the http client to pull the specified keys out of
// the context and add them to the http request as headers.  Note that keys
// will have net/http.CanonicalHeaderKey called on them before being send over
// the wire and that is the form they will be available in the server context.
func CtxValuesToSend(keys ...string) httptransport.ClientOption {
	return httptransport.ClientBefore(func(ctx context.Context, r *http.Request) context.Context {
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				r.Header.Set(k, v)
			}
		}
		return ctx
	})
}

// HTTP Client Decode

// DecodeHTTPSignInResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SignInResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPSignInResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SignInResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPFindUserResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded FindUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPFindUserResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.FindUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserProfileResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserProfileResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserAvatarResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserAvatarResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateUserNameResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateUserResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateUserNameResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateUserResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUpdateStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded UpdateStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUpdateStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.UpdateStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListLikeStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListLikeResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListLikeStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListLikeResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded GetStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.GetStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListRecommendedResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListRecommendedResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListUserTimelineResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListUserTimelineResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLatestFollowingResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded LatestFollowingResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLatestFollowingResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.LatestFollowingResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListRelationshipResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListRelationshipResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListRelationshipResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListRelationshipResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPFollowResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPFollowResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnFollowResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnFollowResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListMessageResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListMessageResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListMessageResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListMessageResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPReadMessageResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPReadMessageResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPGetMessageSummaryResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded MessageSummaryResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPGetMessageSummaryResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.MessageSummaryResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListCommentResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListCommentResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPNewRecommendStatusResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded NewRecommendStatusResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPNewRecommendStatusResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.NewRecommendStatusResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded CreateCommentResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.CreateCommentResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLikeCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLikeCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPUnlikeCommentResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPUnlikeCommentResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPListBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded ListBlacklistResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPListBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.ListBlacklistResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPCreateBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPCreateBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPDeleteBlacklistResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded SimpleResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPDeleteBlacklistResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp pb.SimpleResponse
	if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// HTTP Client Encode

// EncodeHTTPSignInZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a signin request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPSignInZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.SignInRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"signin",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("auth", fmt.Sprint(req.Auth))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPSignInOneRequest is a transport/http.EncodeRequestFunc
// that encodes a signin request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPSignInOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.SignInRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"signin",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("auth", fmt.Sprint(req.Auth))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFindUserZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a finduser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFindUserZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FindUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFindUserOneRequest is a transport/http.EncodeRequestFunc
// that encodes a finduser request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFindUserOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FindUserRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPUpdateUserProfileZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserprofile request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserProfileZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserProfileRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"profile",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserProfileRequest)

	toRet.Uid = req.Uid

	toRet.Gender = req.Gender

	toRet.Mobile = req.Mobile

	toRet.Email = req.Email

	toRet.Address = req.Address

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserProfileOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuserprofile request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserProfileOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserProfileRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"profile",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserProfileRequest)

	toRet.Uid = req.Uid

	toRet.Gender = req.Gender

	toRet.Mobile = req.Mobile

	toRet.Email = req.Email

	toRet.Address = req.Address

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserAvatarZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuseravatar request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserAvatarZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserAvatarRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"avatar",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserAvatarRequest)

	toRet.Uid = req.Uid

	toRet.AttachmentPath = req.AttachmentPath

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserAvatarOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateuseravatar request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserAvatarOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserAvatarRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"avatar",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserAvatarRequest)

	toRet.Uid = req.Uid

	toRet.AttachmentPath = req.AttachmentPath

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserNameZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updateusername request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserNameZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserNameRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"username",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserNameRequest)

	toRet.Uid = req.Uid

	toRet.Username = req.Username

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateUserNameOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updateusername request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateUserNameOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateUserNameRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"username",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateUserNameRequest)

	toRet.Uid = req.Uid

	toRet.Username = req.Username

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusType = req.StatusType

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.Meta = req.Meta

	toRet.FromType = req.FromType

	toRet.Images = req.Images

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusType = req.StatusType

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	toRet.Meta = req.Meta

	toRet.FromType = req.FromType

	toRet.Images = req.Images

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a updatestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"update",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUpdateStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a updatestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUpdateStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UpdateStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"update",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UpdateStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.IsPrivate = req.IsPrivate

	toRet.ShowDuration = req.ShowDuration

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deletestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deletestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a likestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a likestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"unlike",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnLikeStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"unlike",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnLikeStatusRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Statusid = req.Statusid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListLikeStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListLikeStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listlikestatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListLikeStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListLikeRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"like",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("statusid", fmt.Sprint(req.Statusid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("statusid", fmt.Sprint(req.Statusid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a liststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a liststatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRecommendedZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listrecommended request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRecommendedZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"recommended",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRecommendedOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listrecommended request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRecommendedOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"recommended",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListUserTimelineZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listusertimeline request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListUserTimelineZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"timeline",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListUserTimelineOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listusertimeline request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListUserTimelineOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"timeline",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("target_uid", fmt.Sprint(req.TargetUid))

	values.Add("parent_id", fmt.Sprint(req.ParentId))

	values["from_types"] = req.FromTypes

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPLatestFollowingZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a latestfollowing request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLatestFollowingZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LatestFollowingRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"following",
		"latest",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPLatestFollowingOneRequest is a transport/http.EncodeRequestFunc
// that encodes a latestfollowing request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLatestFollowingOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LatestFollowingRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"following",
		"latest",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRelationshipZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listrelationship request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRelationshipZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListRelationshipRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("relation_type", fmt.Sprint(req.RelationType))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListRelationshipOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listrelationship request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListRelationshipOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListRelationshipRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("uid", fmt.Sprint(req.Uid))

	values.Add("relation_type", fmt.Sprint(req.RelationType))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPFollowZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a follow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFollowZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"follow",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.FollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPFollowOneRequest is a transport/http.EncodeRequestFunc
// that encodes a follow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPFollowOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.FollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"follow",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.FollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnFollowZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnFollowZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"unfollow",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnFollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnFollowOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unfollow request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnFollowOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnFollowRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"relation",
		"unfollow",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnFollowRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListMessageZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListMessageZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListMessageOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListMessageOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPReadMessageZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a readmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReadMessageZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReadMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"read",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.ReadMessageRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.LatestID = req.LatestID

	toRet.Ids = req.Ids

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPReadMessageOneRequest is a transport/http.EncodeRequestFunc
// that encodes a readmessage request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPReadMessageOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ReadMessageRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"read",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.ReadMessageRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.LatestID = req.LatestID

	toRet.Ids = req.Ids

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPGetMessageSummaryZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a getmessagesummary request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetMessageSummaryZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetMessageSummaryRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"summary",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPGetMessageSummaryOneRequest is a transport/http.EncodeRequestFunc
// that encodes a getmessagesummary request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPGetMessageSummaryOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.GetMessageSummaryRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"message",
		"summary",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"list",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("status_id", fmt.Sprint(req.StatusId))

	values.Add("topic_id", fmt.Sprint(req.TopicId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("status_id", fmt.Sprint(req.StatusId))

	values.Add("topic_id", fmt.Sprint(req.TopicId))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewRecommendStatusZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a newrecommendstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewRecommendStatusZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewRecommendStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_recommend",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("last_recommend_time", fmt.Sprint(req.LastRecommendTime))

	values.Add("last_common_time", fmt.Sprint(req.LastCommonTime))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPNewRecommendStatusOneRequest is a transport/http.EncodeRequestFunc
// that encodes a newrecommendstatus request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPNewRecommendStatusOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.NewRecommendStatusRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"status",
		"new_recommend",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("current_uid", fmt.Sprint(req.CurrentUid))

	values.Add("last_recommend_time", fmt.Sprint(req.LastRecommendTime))

	values.Add("last_common_time", fmt.Sprint(req.LastCommonTime))

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createcomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.StatusId = req.StatusId

	toRet.ParentId = req.ParentId

	toRet.Content = req.Content

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deletecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Id = req.Id

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deletecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.Id = req.Id

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a likecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"like",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPLikeCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a likecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLikeCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.LikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"like",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.LikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeCommentZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeCommentZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnlikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"unlike",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnlikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPUnlikeCommentOneRequest is a transport/http.EncodeRequestFunc
// that encodes a unlikecomment request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPUnlikeCommentOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.UnlikeCommentRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"comment",
		"unlike",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.UnlikeCommentRequest)

	toRet.CurrentUid = req.CurrentUid

	toRet.CommentId = req.CommentId

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPListBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a listblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPListBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a listblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPListBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.ListBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"list",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("uid", fmt.Sprint(req.Uid))

	tmp, err = json.Marshal(req.Paginator)
	if err != nil {
		return errors.Wrap(err, "failed to marshal req.Paginator")
	}
	strval = string(tmp)
	values.Add("paginator", strval)

	r.URL.RawQuery = values.Encode()
	return nil
}

// EncodeHTTPCreateBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a createblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"create",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPCreateBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a createblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPCreateBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.CreateBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"create",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.CreateBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteBlacklistZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a deleteblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteBlacklistZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"delete",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

// EncodeHTTPDeleteBlacklistOneRequest is a transport/http.EncodeRequestFunc
// that encodes a deleteblacklist request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPDeleteBlacklistOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*pb.DeleteBlacklistRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"user",
		"blacklist",
		"delete",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*pb.DeleteBlacklistRequest)

	toRet.Uid = req.Uid

	toRet.TargetUid = req.TargetUid

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}

func errorDecoder(buf []byte) error {
	var w errorWrapper
	if err := json.Unmarshal(buf, &w); err != nil {
		const size = 8196
		if len(buf) > size {
			buf = buf[:size]
		}
		return fmt.Errorf("response body '%s': cannot parse non-json request body", buf)
	}

	return errors.New(w.Error)
}

type errorWrapper struct {
	Error string `json:"error"`
}
