// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 5f7d5bf015
// Version Date: 2021-11-26T09:27:01Z

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"

	"context"

	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"

	// This service
	pb "github.com/mises-id/sns-socialsvc/proto"
)

const contentType = "application/json; charset=utf-8"

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.NewSocialClient
	_ = io.Copy
	_ = errors.Wrap
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, responseEncoder httptransport.EncodeResponseFunc, options ...httptransport.ServerOption) http.Handler {
	if responseEncoder == nil {
		responseEncoder = EncodeHTTPGenericResponse
	}
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}
	serverOptions = append(serverOptions, options...)
	m := mux.NewRouter()

	m.Methods("GET").Path("/signin/").Handler(httptransport.NewServer(
		endpoints.SignInEndpoint,
		DecodeHTTPSignInZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/signin").Handler(httptransport.NewServer(
		endpoints.SignInEndpoint,
		DecodeHTTPSignInOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/").Handler(httptransport.NewServer(
		endpoints.FindUserEndpoint,
		DecodeHTTPFindUserZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user").Handler(httptransport.NewServer(
		endpoints.FindUserEndpoint,
		DecodeHTTPFindUserOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/profile/").Handler(httptransport.NewServer(
		endpoints.UpdateUserProfileEndpoint,
		DecodeHTTPUpdateUserProfileZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/profile").Handler(httptransport.NewServer(
		endpoints.UpdateUserProfileEndpoint,
		DecodeHTTPUpdateUserProfileOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/avatar/").Handler(httptransport.NewServer(
		endpoints.UpdateUserAvatarEndpoint,
		DecodeHTTPUpdateUserAvatarZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/avatar").Handler(httptransport.NewServer(
		endpoints.UpdateUserAvatarEndpoint,
		DecodeHTTPUpdateUserAvatarOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/username/").Handler(httptransport.NewServer(
		endpoints.UpdateUserNameEndpoint,
		DecodeHTTPUpdateUserNameZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/username").Handler(httptransport.NewServer(
		endpoints.UpdateUserNameEndpoint,
		DecodeHTTPUpdateUserNameOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/create/").Handler(httptransport.NewServer(
		endpoints.CreateStatusEndpoint,
		DecodeHTTPCreateStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/create").Handler(httptransport.NewServer(
		endpoints.CreateStatusEndpoint,
		DecodeHTTPCreateStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/delete/").Handler(httptransport.NewServer(
		endpoints.DeleteStatusEndpoint,
		DecodeHTTPDeleteStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/delete").Handler(httptransport.NewServer(
		endpoints.DeleteStatusEndpoint,
		DecodeHTTPDeleteStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/like/").Handler(httptransport.NewServer(
		endpoints.LikeStatusEndpoint,
		DecodeHTTPLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/like").Handler(httptransport.NewServer(
		endpoints.LikeStatusEndpoint,
		DecodeHTTPLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/unlike/").Handler(httptransport.NewServer(
		endpoints.UnLikeStatusEndpoint,
		DecodeHTTPUnLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/unlike").Handler(httptransport.NewServer(
		endpoints.UnLikeStatusEndpoint,
		DecodeHTTPUnLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/like/list").Handler(httptransport.NewServer(
		endpoints.ListLikeStatusEndpoint,
		DecodeHTTPListLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/like/list").Handler(httptransport.NewServer(
		endpoints.ListLikeStatusEndpoint,
		DecodeHTTPListLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/").Handler(httptransport.NewServer(
		endpoints.GetStatusEndpoint,
		DecodeHTTPGetStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status").Handler(httptransport.NewServer(
		endpoints.GetStatusEndpoint,
		DecodeHTTPGetStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/list/").Handler(httptransport.NewServer(
		endpoints.ListStatusEndpoint,
		DecodeHTTPListStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/list").Handler(httptransport.NewServer(
		endpoints.ListStatusEndpoint,
		DecodeHTTPListStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/recommended/").Handler(httptransport.NewServer(
		endpoints.ListRecommendedEndpoint,
		DecodeHTTPListRecommendedZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/recommended").Handler(httptransport.NewServer(
		endpoints.ListRecommendedEndpoint,
		DecodeHTTPListRecommendedOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/timeline/").Handler(httptransport.NewServer(
		endpoints.ListUserTimelineEndpoint,
		DecodeHTTPListUserTimelineZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/timeline").Handler(httptransport.NewServer(
		endpoints.ListUserTimelineEndpoint,
		DecodeHTTPListUserTimelineOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/following/latest/").Handler(httptransport.NewServer(
		endpoints.LatestFollowingEndpoint,
		DecodeHTTPLatestFollowingZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/following/latest").Handler(httptransport.NewServer(
		endpoints.LatestFollowingEndpoint,
		DecodeHTTPLatestFollowingOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/relation/list/").Handler(httptransport.NewServer(
		endpoints.ListRelationshipEndpoint,
		DecodeHTTPListRelationshipZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/relation/list").Handler(httptransport.NewServer(
		endpoints.ListRelationshipEndpoint,
		DecodeHTTPListRelationshipOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/relation/follow/").Handler(httptransport.NewServer(
		endpoints.FollowEndpoint,
		DecodeHTTPFollowZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/relation/follow").Handler(httptransport.NewServer(
		endpoints.FollowEndpoint,
		DecodeHTTPFollowOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/relation/unfollow/").Handler(httptransport.NewServer(
		endpoints.UnFollowEndpoint,
		DecodeHTTPUnFollowZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/relation/unfollow").Handler(httptransport.NewServer(
		endpoints.UnFollowEndpoint,
		DecodeHTTPUnFollowOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/message/list/").Handler(httptransport.NewServer(
		endpoints.ListMessageEndpoint,
		DecodeHTTPListMessageZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/message/list").Handler(httptransport.NewServer(
		endpoints.ListMessageEndpoint,
		DecodeHTTPListMessageOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/message/read/").Handler(httptransport.NewServer(
		endpoints.ReadMessageEndpoint,
		DecodeHTTPReadMessageZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/message/read").Handler(httptransport.NewServer(
		endpoints.ReadMessageEndpoint,
		DecodeHTTPReadMessageOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/comment/list/").Handler(httptransport.NewServer(
		endpoints.ListCommentEndpoint,
		DecodeHTTPListCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/comment/list").Handler(httptransport.NewServer(
		endpoints.ListCommentEndpoint,
		DecodeHTTPListCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/create/").Handler(httptransport.NewServer(
		endpoints.CreateCommentEndpoint,
		DecodeHTTPCreateCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/create").Handler(httptransport.NewServer(
		endpoints.CreateCommentEndpoint,
		DecodeHTTPCreateCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/like/").Handler(httptransport.NewServer(
		endpoints.LikeCommentEndpoint,
		DecodeHTTPLikeCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/like").Handler(httptransport.NewServer(
		endpoints.LikeCommentEndpoint,
		DecodeHTTPLikeCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/unlike/").Handler(httptransport.NewServer(
		endpoints.UnlikeCommentEndpoint,
		DecodeHTTPUnlikeCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/unlike").Handler(httptransport.NewServer(
		endpoints.UnlikeCommentEndpoint,
		DecodeHTTPUnlikeCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/blacklist/list").Handler(httptransport.NewServer(
		endpoints.ListBlacklistEndpoint,
		DecodeHTTPListBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user/blacklist/list").Handler(httptransport.NewServer(
		endpoints.ListBlacklistEndpoint,
		DecodeHTTPListBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/blacklist/create/").Handler(httptransport.NewServer(
		endpoints.CreateBlacklistEndpoint,
		DecodeHTTPCreateBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/blacklist/create").Handler(httptransport.NewServer(
		endpoints.CreateBlacklistEndpoint,
		DecodeHTTPCreateBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/blacklist/delete/").Handler(httptransport.NewServer(
		endpoints.DeleteBlacklistEndpoint,
		DecodeHTTPDeleteBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/blacklist/delete").Handler(httptransport.NewServer(
		endpoints.DeleteBlacklistEndpoint,
		DecodeHTTPDeleteBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode

// DecodeHTTPSignInZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded signin request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSignInZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SignInRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AuthSignInStrArr, ok := queryParams["auth"]; ok {
		AuthSignInStr := AuthSignInStrArr[0]
		AuthSignIn := AuthSignInStr
		req.Auth = AuthSignIn
	}

	return &req, err
}

// DecodeHTTPSignInOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded signin request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSignInOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SignInRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AuthSignInStrArr, ok := queryParams["auth"]; ok {
		AuthSignInStr := AuthSignInStrArr[0]
		AuthSignIn := AuthSignInStr
		req.Auth = AuthSignIn
	}

	return &req, err
}

// DecodeHTTPFindUserZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded finduser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindUserZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidFindUserStrArr, ok := queryParams["uid"]; ok {
		UidFindUserStr := UidFindUserStrArr[0]
		UidFindUser, err := strconv.ParseUint(UidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidFindUser from query, queryParams: %v", queryParams))
		}
		req.Uid = UidFindUser
	}

	return &req, err
}

// DecodeHTTPFindUserOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded finduser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindUserOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidFindUserStrArr, ok := queryParams["uid"]; ok {
		UidFindUserStr := UidFindUserStrArr[0]
		UidFindUser, err := strconv.ParseUint(UidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidFindUser from query, queryParams: %v", queryParams))
		}
		req.Uid = UidFindUser
	}

	return &req, err
}

// DecodeHTTPUpdateUserProfileZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserprofile request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserProfileZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserProfileRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserProfileOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserprofile request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserProfileOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserProfileRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserAvatarZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuseravatar request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserAvatarZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserAvatarRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserAvatarOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuseravatar request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserAvatarOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserAvatarRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserNameZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateusername request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserNameZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserNameRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserNameOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateusername request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserNameOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserNameRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListLikeStatusStrArr, ok := queryParams["uid"]; ok {
		UidListLikeStatusStr := UidListLikeStatusStrArr[0]
		UidListLikeStatus, err := strconv.ParseUint(UidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListLikeStatus
	}

	if PaginatorListLikeStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStatusStr := PaginatorListLikeStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLikeStatus from %v", PaginatorListLikeStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPListLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListLikeStatusStrArr, ok := queryParams["uid"]; ok {
		UidListLikeStatusStr := UidListLikeStatusStrArr[0]
		UidListLikeStatus, err := strconv.ParseUint(UidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListLikeStatus
	}

	if PaginatorListLikeStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStatusStr := PaginatorListLikeStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLikeStatus from %v", PaginatorListLikeStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPGetStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetStatusStr := CurrentUidGetStatusStrArr[0]
		CurrentUidGetStatus, err := strconv.ParseUint(CurrentUidGetStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetStatus
	}

	if StatusidGetStatusStrArr, ok := queryParams["statusid"]; ok {
		StatusidGetStatusStr := StatusidGetStatusStrArr[0]
		StatusidGetStatus := StatusidGetStatusStr
		req.Statusid = StatusidGetStatus
	}

	return &req, err
}

// DecodeHTTPGetStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetStatusStr := CurrentUidGetStatusStrArr[0]
		CurrentUidGetStatus, err := strconv.ParseUint(CurrentUidGetStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetStatus
	}

	if StatusidGetStatusStrArr, ok := queryParams["statusid"]; ok {
		StatusidGetStatusStr := StatusidGetStatusStrArr[0]
		StatusidGetStatus := StatusidGetStatusStr
		req.Statusid = StatusidGetStatus
	}

	return &req, err
}

// DecodeHTTPListStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded liststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListStatusStr := CurrentUidListStatusStrArr[0]
		CurrentUidListStatus, err := strconv.ParseUint(CurrentUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListStatus
	}

	if TargetUidListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListStatusStr := TargetUidListStatusStrArr[0]
		TargetUidListStatus, err := strconv.ParseUint(TargetUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListStatus
	}

	if ParentIdListStatusStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListStatusStr := ParentIdListStatusStrArr[0]
		ParentIdListStatus := ParentIdListStatusStr
		req.ParentId = ParentIdListStatus
	}

	if FromTypesListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListStatusStr := FromTypesListStatusStrArr[0]

		var FromTypesListStatus []string
		if len(FromTypesListStatusStrArr) > 1 {
			FromTypesListStatus = FromTypesListStatusStrArr
		} else {
			FromTypesListStatus = strings.Split(FromTypesListStatusStr, ",")
		}
		req.FromTypes = FromTypesListStatus
	}

	if PaginatorListStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListStatusStr := PaginatorListStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListStatus from %v", PaginatorListStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPListStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded liststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListStatusStr := CurrentUidListStatusStrArr[0]
		CurrentUidListStatus, err := strconv.ParseUint(CurrentUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListStatus
	}

	if TargetUidListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListStatusStr := TargetUidListStatusStrArr[0]
		TargetUidListStatus, err := strconv.ParseUint(TargetUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListStatus
	}

	if ParentIdListStatusStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListStatusStr := ParentIdListStatusStrArr[0]
		ParentIdListStatus := ParentIdListStatusStr
		req.ParentId = ParentIdListStatus
	}

	if FromTypesListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListStatusStr := FromTypesListStatusStrArr[0]

		var FromTypesListStatus []string
		if len(FromTypesListStatusStrArr) > 1 {
			FromTypesListStatus = FromTypesListStatusStrArr
		} else {
			FromTypesListStatus = strings.Split(FromTypesListStatusStr, ",")
		}
		req.FromTypes = FromTypesListStatus
	}

	if PaginatorListStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListStatusStr := PaginatorListStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListStatus from %v", PaginatorListStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPListRecommendedZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrecommended request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRecommendedZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRecommendedStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRecommendedStr := CurrentUidListRecommendedStrArr[0]
		CurrentUidListRecommended, err := strconv.ParseUint(CurrentUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRecommended
	}

	if TargetUidListRecommendedStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListRecommendedStr := TargetUidListRecommendedStrArr[0]
		TargetUidListRecommended, err := strconv.ParseUint(TargetUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListRecommended
	}

	if ParentIdListRecommendedStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListRecommendedStr := ParentIdListRecommendedStrArr[0]
		ParentIdListRecommended := ParentIdListRecommendedStr
		req.ParentId = ParentIdListRecommended
	}

	if FromTypesListRecommendedStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListRecommendedStr := FromTypesListRecommendedStrArr[0]

		var FromTypesListRecommended []string
		if len(FromTypesListRecommendedStrArr) > 1 {
			FromTypesListRecommended = FromTypesListRecommendedStrArr
		} else {
			FromTypesListRecommended = strings.Split(FromTypesListRecommendedStr, ",")
		}
		req.FromTypes = FromTypesListRecommended
	}

	if PaginatorListRecommendedStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRecommendedStr := PaginatorListRecommendedStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRecommendedStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRecommended from %v", PaginatorListRecommendedStr)
		}

	}

	return &req, err
}

// DecodeHTTPListRecommendedOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrecommended request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRecommendedOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRecommendedStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRecommendedStr := CurrentUidListRecommendedStrArr[0]
		CurrentUidListRecommended, err := strconv.ParseUint(CurrentUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRecommended
	}

	if TargetUidListRecommendedStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListRecommendedStr := TargetUidListRecommendedStrArr[0]
		TargetUidListRecommended, err := strconv.ParseUint(TargetUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListRecommended
	}

	if ParentIdListRecommendedStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListRecommendedStr := ParentIdListRecommendedStrArr[0]
		ParentIdListRecommended := ParentIdListRecommendedStr
		req.ParentId = ParentIdListRecommended
	}

	if FromTypesListRecommendedStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListRecommendedStr := FromTypesListRecommendedStrArr[0]

		var FromTypesListRecommended []string
		if len(FromTypesListRecommendedStrArr) > 1 {
			FromTypesListRecommended = FromTypesListRecommendedStrArr
		} else {
			FromTypesListRecommended = strings.Split(FromTypesListRecommendedStr, ",")
		}
		req.FromTypes = FromTypesListRecommended
	}

	if PaginatorListRecommendedStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRecommendedStr := PaginatorListRecommendedStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRecommendedStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRecommended from %v", PaginatorListRecommendedStr)
		}

	}

	return &req, err
}

// DecodeHTTPListUserTimelineZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listusertimeline request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListUserTimelineZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListUserTimelineStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListUserTimelineStr := CurrentUidListUserTimelineStrArr[0]
		CurrentUidListUserTimeline, err := strconv.ParseUint(CurrentUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListUserTimeline
	}

	if TargetUidListUserTimelineStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListUserTimelineStr := TargetUidListUserTimelineStrArr[0]
		TargetUidListUserTimeline, err := strconv.ParseUint(TargetUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListUserTimeline
	}

	if ParentIdListUserTimelineStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListUserTimelineStr := ParentIdListUserTimelineStrArr[0]
		ParentIdListUserTimeline := ParentIdListUserTimelineStr
		req.ParentId = ParentIdListUserTimeline
	}

	if FromTypesListUserTimelineStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListUserTimelineStr := FromTypesListUserTimelineStrArr[0]

		var FromTypesListUserTimeline []string
		if len(FromTypesListUserTimelineStrArr) > 1 {
			FromTypesListUserTimeline = FromTypesListUserTimelineStrArr
		} else {
			FromTypesListUserTimeline = strings.Split(FromTypesListUserTimelineStr, ",")
		}
		req.FromTypes = FromTypesListUserTimeline
	}

	if PaginatorListUserTimelineStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListUserTimelineStr := PaginatorListUserTimelineStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListUserTimelineStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListUserTimeline from %v", PaginatorListUserTimelineStr)
		}

	}

	return &req, err
}

// DecodeHTTPListUserTimelineOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listusertimeline request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListUserTimelineOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListUserTimelineStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListUserTimelineStr := CurrentUidListUserTimelineStrArr[0]
		CurrentUidListUserTimeline, err := strconv.ParseUint(CurrentUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListUserTimeline
	}

	if TargetUidListUserTimelineStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListUserTimelineStr := TargetUidListUserTimelineStrArr[0]
		TargetUidListUserTimeline, err := strconv.ParseUint(TargetUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListUserTimeline
	}

	if ParentIdListUserTimelineStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListUserTimelineStr := ParentIdListUserTimelineStrArr[0]
		ParentIdListUserTimeline := ParentIdListUserTimelineStr
		req.ParentId = ParentIdListUserTimeline
	}

	if FromTypesListUserTimelineStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListUserTimelineStr := FromTypesListUserTimelineStrArr[0]

		var FromTypesListUserTimeline []string
		if len(FromTypesListUserTimelineStrArr) > 1 {
			FromTypesListUserTimeline = FromTypesListUserTimelineStrArr
		} else {
			FromTypesListUserTimeline = strings.Split(FromTypesListUserTimelineStr, ",")
		}
		req.FromTypes = FromTypesListUserTimeline
	}

	if PaginatorListUserTimelineStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListUserTimelineStr := PaginatorListUserTimelineStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListUserTimelineStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListUserTimeline from %v", PaginatorListUserTimelineStr)
		}

	}

	return &req, err
}

// DecodeHTTPLatestFollowingZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded latestfollowing request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLatestFollowingZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LatestFollowingRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidLatestFollowingStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidLatestFollowingStr := CurrentUidLatestFollowingStrArr[0]
		CurrentUidLatestFollowing, err := strconv.ParseUint(CurrentUidLatestFollowingStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidLatestFollowing from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidLatestFollowing
	}

	return &req, err
}

// DecodeHTTPLatestFollowingOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded latestfollowing request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLatestFollowingOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LatestFollowingRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidLatestFollowingStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidLatestFollowingStr := CurrentUidLatestFollowingStrArr[0]
		CurrentUidLatestFollowing, err := strconv.ParseUint(CurrentUidLatestFollowingStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidLatestFollowing from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidLatestFollowing
	}

	return &req, err
}

// DecodeHTTPListRelationshipZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrelationship request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRelationshipZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListRelationshipRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRelationshipStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRelationshipStr := CurrentUidListRelationshipStrArr[0]
		CurrentUidListRelationship, err := strconv.ParseUint(CurrentUidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRelationship from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRelationship
	}

	if UidListRelationshipStrArr, ok := queryParams["uid"]; ok {
		UidListRelationshipStr := UidListRelationshipStrArr[0]
		UidListRelationship, err := strconv.ParseUint(UidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListRelationship from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListRelationship
	}

	if RelationTypeListRelationshipStrArr, ok := queryParams["relation_type"]; ok {
		RelationTypeListRelationshipStr := RelationTypeListRelationshipStrArr[0]
		RelationTypeListRelationship := RelationTypeListRelationshipStr
		req.RelationType = RelationTypeListRelationship
	}

	if PaginatorListRelationshipStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRelationshipStr := PaginatorListRelationshipStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRelationshipStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRelationship from %v", PaginatorListRelationshipStr)
		}

	}

	return &req, err
}

// DecodeHTTPListRelationshipOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrelationship request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRelationshipOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListRelationshipRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRelationshipStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRelationshipStr := CurrentUidListRelationshipStrArr[0]
		CurrentUidListRelationship, err := strconv.ParseUint(CurrentUidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRelationship from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRelationship
	}

	if UidListRelationshipStrArr, ok := queryParams["uid"]; ok {
		UidListRelationshipStr := UidListRelationshipStrArr[0]
		UidListRelationship, err := strconv.ParseUint(UidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListRelationship from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListRelationship
	}

	if RelationTypeListRelationshipStrArr, ok := queryParams["relation_type"]; ok {
		RelationTypeListRelationshipStr := RelationTypeListRelationshipStrArr[0]
		RelationTypeListRelationship := RelationTypeListRelationshipStr
		req.RelationType = RelationTypeListRelationship
	}

	if PaginatorListRelationshipStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRelationshipStr := PaginatorListRelationshipStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRelationshipStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRelationship from %v", PaginatorListRelationshipStr)
		}

	}

	return &req, err
}

// DecodeHTTPFollowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded follow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFollowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPFollowOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded follow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFollowOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnFollowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnFollowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnFollowOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnFollowOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListMessageZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListMessageZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListMessageStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListMessageStr := CurrentUidListMessageStrArr[0]
		CurrentUidListMessage, err := strconv.ParseUint(CurrentUidListMessageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListMessage from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListMessage
	}

	if PaginatorListMessageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListMessageStr := PaginatorListMessageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListMessageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListMessage from %v", PaginatorListMessageStr)
		}

	}

	return &req, err
}

// DecodeHTTPListMessageOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListMessageOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListMessageStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListMessageStr := CurrentUidListMessageStrArr[0]
		CurrentUidListMessage, err := strconv.ParseUint(CurrentUidListMessageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListMessage from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListMessage
	}

	if PaginatorListMessageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListMessageStr := PaginatorListMessageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListMessageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListMessage from %v", PaginatorListMessageStr)
		}

	}

	return &req, err
}

// DecodeHTTPReadMessageZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded readmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReadMessageZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReadMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPReadMessageOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded readmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReadMessageOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReadMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListCommentStr := CurrentUidListCommentStrArr[0]
		CurrentUidListComment, err := strconv.ParseUint(CurrentUidListCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListComment
	}

	if StatusIdListCommentStrArr, ok := queryParams["status_id"]; ok {
		StatusIdListCommentStr := StatusIdListCommentStrArr[0]
		StatusIdListComment := StatusIdListCommentStr
		req.StatusId = StatusIdListComment
	}

	if TopicIdListCommentStrArr, ok := queryParams["topic_id"]; ok {
		TopicIdListCommentStr := TopicIdListCommentStrArr[0]
		TopicIdListComment := TopicIdListCommentStr
		req.TopicId = TopicIdListComment
	}

	if LastIdListCommentStrArr, ok := queryParams["last_id"]; ok {
		LastIdListCommentStr := LastIdListCommentStrArr[0]
		LastIdListComment := LastIdListCommentStr
		req.LastId = LastIdListComment
	}

	if PaginatorListCommentStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListCommentStr := PaginatorListCommentStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListCommentStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListComment from %v", PaginatorListCommentStr)
		}

	}

	return &req, err
}

// DecodeHTTPListCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListCommentStr := CurrentUidListCommentStrArr[0]
		CurrentUidListComment, err := strconv.ParseUint(CurrentUidListCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListComment
	}

	if StatusIdListCommentStrArr, ok := queryParams["status_id"]; ok {
		StatusIdListCommentStr := StatusIdListCommentStrArr[0]
		StatusIdListComment := StatusIdListCommentStr
		req.StatusId = StatusIdListComment
	}

	if TopicIdListCommentStrArr, ok := queryParams["topic_id"]; ok {
		TopicIdListCommentStr := TopicIdListCommentStrArr[0]
		TopicIdListComment := TopicIdListCommentStr
		req.TopicId = TopicIdListComment
	}

	if LastIdListCommentStrArr, ok := queryParams["last_id"]; ok {
		LastIdListCommentStr := LastIdListCommentStrArr[0]
		LastIdListComment := LastIdListCommentStr
		req.LastId = LastIdListComment
	}

	if PaginatorListCommentStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListCommentStr := PaginatorListCommentStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListCommentStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListComment from %v", PaginatorListCommentStr)
		}

	}

	return &req, err
}

// DecodeHTTPCreateCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnlikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnlikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListBlacklistStrArr, ok := queryParams["uid"]; ok {
		UidListBlacklistStr := UidListBlacklistStrArr[0]
		UidListBlacklist, err := strconv.ParseUint(UidListBlacklistStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListBlacklist from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListBlacklist
	}

	if PaginatorListBlacklistStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListBlacklistStr := PaginatorListBlacklistStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListBlacklistStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListBlacklist from %v", PaginatorListBlacklistStr)
		}

	}

	return &req, err
}

// DecodeHTTPListBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListBlacklistStrArr, ok := queryParams["uid"]; ok {
		UidListBlacklistStr := UidListBlacklistStrArr[0]
		UidListBlacklist, err := strconv.ParseUint(UidListBlacklistStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListBlacklist from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListBlacklist
	}

	if PaginatorListBlacklistStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListBlacklistStr := PaginatorListBlacklistStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListBlacklistStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListBlacklist from %v", PaginatorListBlacklistStr)
		}

	}

	return &req, err
}

// DecodeHTTPCreateBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deleteblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deleteblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: false,
		OrigName:     true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

// encodePathParams encodes `mux.Vars()` with dot notations into JSON objects
// to be unmarshaled into non-basetype fields.
// e.g. {"book.name": "books/1"} -> {"book": {"name": "books/1"}}
func encodePathParams(vars map[string]string) map[string]string {
	var recur func(path, value string, data map[string]interface{})
	recur = func(path, value string, data map[string]interface{}) {
		parts := strings.SplitN(path, ".", 2)
		key := parts[0]
		if len(parts) == 1 {
			data[key] = value
		} else {
			if _, ok := data[key]; !ok {
				data[key] = make(map[string]interface{})
			}
			recur(parts[1], value, data[key].(map[string]interface{}))
		}
	}

	data := make(map[string]interface{})
	for key, val := range vars {
		recur(key, val, data)
	}

	ret := make(map[string]string)
	for key, val := range data {
		switch val := val.(type) {
		case string:
			ret[key] = val
		case map[string]interface{}:
			m, _ := json.Marshal(val)
			ret[key] = string(m)
		}
	}
	return ret
}
