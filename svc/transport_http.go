// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 5f7d5bf015
// Version Date: 2021-11-26T09:27:01Z

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"

	"context"

	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"

	// This service
	pb "github.com/mises-id/sns-socialsvc/proto"
)

const contentType = "application/json; charset=utf-8"

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.NewSocialClient
	_ = io.Copy
	_ = errors.Wrap
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, responseEncoder httptransport.EncodeResponseFunc, options ...httptransport.ServerOption) http.Handler {
	if responseEncoder == nil {
		responseEncoder = EncodeHTTPGenericResponse
	}
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}
	serverOptions = append(serverOptions, options...)
	m := mux.NewRouter()

	m.Methods("GET").Path("/signin/").Handler(httptransport.NewServer(
		endpoints.SignInEndpoint,
		DecodeHTTPSignInZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/signin").Handler(httptransport.NewServer(
		endpoints.SignInEndpoint,
		DecodeHTTPSignInOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/").Handler(httptransport.NewServer(
		endpoints.FindUserEndpoint,
		DecodeHTTPFindUserZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user").Handler(httptransport.NewServer(
		endpoints.FindUserEndpoint,
		DecodeHTTPFindUserOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/mises_user/").Handler(httptransport.NewServer(
		endpoints.FindMisesUserEndpoint,
		DecodeHTTPFindMisesUserZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/mises_user").Handler(httptransport.NewServer(
		endpoints.FindMisesUserEndpoint,
		DecodeHTTPFindMisesUserOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/profile/").Handler(httptransport.NewServer(
		endpoints.UpdateUserProfileEndpoint,
		DecodeHTTPUpdateUserProfileZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/profile").Handler(httptransport.NewServer(
		endpoints.UpdateUserProfileEndpoint,
		DecodeHTTPUpdateUserProfileOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/avatar/").Handler(httptransport.NewServer(
		endpoints.UpdateUserAvatarEndpoint,
		DecodeHTTPUpdateUserAvatarZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/avatar").Handler(httptransport.NewServer(
		endpoints.UpdateUserAvatarEndpoint,
		DecodeHTTPUpdateUserAvatarOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/username/").Handler(httptransport.NewServer(
		endpoints.UpdateUserNameEndpoint,
		DecodeHTTPUpdateUserNameZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/username").Handler(httptransport.NewServer(
		endpoints.UpdateUserNameEndpoint,
		DecodeHTTPUpdateUserNameOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/create/").Handler(httptransport.NewServer(
		endpoints.CreateStatusEndpoint,
		DecodeHTTPCreateStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/create").Handler(httptransport.NewServer(
		endpoints.CreateStatusEndpoint,
		DecodeHTTPCreateStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/update/").Handler(httptransport.NewServer(
		endpoints.UpdateStatusEndpoint,
		DecodeHTTPUpdateStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/update").Handler(httptransport.NewServer(
		endpoints.UpdateStatusEndpoint,
		DecodeHTTPUpdateStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/delete/").Handler(httptransport.NewServer(
		endpoints.DeleteStatusEndpoint,
		DecodeHTTPDeleteStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/delete").Handler(httptransport.NewServer(
		endpoints.DeleteStatusEndpoint,
		DecodeHTTPDeleteStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/like/").Handler(httptransport.NewServer(
		endpoints.LikeStatusEndpoint,
		DecodeHTTPLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/like").Handler(httptransport.NewServer(
		endpoints.LikeStatusEndpoint,
		DecodeHTTPLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/status/unlike/").Handler(httptransport.NewServer(
		endpoints.UnLikeStatusEndpoint,
		DecodeHTTPUnLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/status/unlike").Handler(httptransport.NewServer(
		endpoints.UnLikeStatusEndpoint,
		DecodeHTTPUnLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/like/list").Handler(httptransport.NewServer(
		endpoints.ListLikeStatusEndpoint,
		DecodeHTTPListLikeStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/like/list").Handler(httptransport.NewServer(
		endpoints.ListLikeStatusEndpoint,
		DecodeHTTPListLikeStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/nft_asset/like/").Handler(httptransport.NewServer(
		endpoints.LikeNftAssetEndpoint,
		DecodeHTTPLikeNftAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/nft_asset/like").Handler(httptransport.NewServer(
		endpoints.LikeNftAssetEndpoint,
		DecodeHTTPLikeNftAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/nft_asset/unlike/").Handler(httptransport.NewServer(
		endpoints.UnlikeNftAssetEndpoint,
		DecodeHTTPUnlikeNftAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/nft_asset/unlike").Handler(httptransport.NewServer(
		endpoints.UnlikeNftAssetEndpoint,
		DecodeHTTPUnlikeNftAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/").Handler(httptransport.NewServer(
		endpoints.GetStatusEndpoint,
		DecodeHTTPGetStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status").Handler(httptransport.NewServer(
		endpoints.GetStatusEndpoint,
		DecodeHTTPGetStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/list/").Handler(httptransport.NewServer(
		endpoints.ListStatusEndpoint,
		DecodeHTTPListStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/list").Handler(httptransport.NewServer(
		endpoints.ListStatusEndpoint,
		DecodeHTTPListStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/new_list/").Handler(httptransport.NewServer(
		endpoints.NewListStatusEndpoint,
		DecodeHTTPNewListStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/new_list").Handler(httptransport.NewServer(
		endpoints.NewListStatusEndpoint,
		DecodeHTTPNewListStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/recommended/").Handler(httptransport.NewServer(
		endpoints.ListRecommendedEndpoint,
		DecodeHTTPListRecommendedZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/recommended").Handler(httptransport.NewServer(
		endpoints.ListRecommendedEndpoint,
		DecodeHTTPListRecommendedOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/timeline/").Handler(httptransport.NewServer(
		endpoints.ListUserTimelineEndpoint,
		DecodeHTTPListUserTimelineZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/timeline").Handler(httptransport.NewServer(
		endpoints.ListUserTimelineEndpoint,
		DecodeHTTPListUserTimelineOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/following/latest/").Handler(httptransport.NewServer(
		endpoints.LatestFollowingEndpoint,
		DecodeHTTPLatestFollowingZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/following/latest").Handler(httptransport.NewServer(
		endpoints.LatestFollowingEndpoint,
		DecodeHTTPLatestFollowingOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/relation/list/").Handler(httptransport.NewServer(
		endpoints.ListRelationshipEndpoint,
		DecodeHTTPListRelationshipZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/relation/list").Handler(httptransport.NewServer(
		endpoints.ListRelationshipEndpoint,
		DecodeHTTPListRelationshipOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/relation/follow/").Handler(httptransport.NewServer(
		endpoints.FollowEndpoint,
		DecodeHTTPFollowZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/relation/follow").Handler(httptransport.NewServer(
		endpoints.FollowEndpoint,
		DecodeHTTPFollowOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/relation/unfollow/").Handler(httptransport.NewServer(
		endpoints.UnFollowEndpoint,
		DecodeHTTPUnFollowZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/relation/unfollow").Handler(httptransport.NewServer(
		endpoints.UnFollowEndpoint,
		DecodeHTTPUnFollowOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/message/list/").Handler(httptransport.NewServer(
		endpoints.ListMessageEndpoint,
		DecodeHTTPListMessageZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/message/list").Handler(httptransport.NewServer(
		endpoints.ListMessageEndpoint,
		DecodeHTTPListMessageOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/message/read/").Handler(httptransport.NewServer(
		endpoints.ReadMessageEndpoint,
		DecodeHTTPReadMessageZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/message/read").Handler(httptransport.NewServer(
		endpoints.ReadMessageEndpoint,
		DecodeHTTPReadMessageOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/message/summary/").Handler(httptransport.NewServer(
		endpoints.GetMessageSummaryEndpoint,
		DecodeHTTPGetMessageSummaryZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/message/summary").Handler(httptransport.NewServer(
		endpoints.GetMessageSummaryEndpoint,
		DecodeHTTPGetMessageSummaryOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/comment/list/").Handler(httptransport.NewServer(
		endpoints.ListCommentEndpoint,
		DecodeHTTPListCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/comment/list").Handler(httptransport.NewServer(
		endpoints.ListCommentEndpoint,
		DecodeHTTPListCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/like/list/").Handler(httptransport.NewServer(
		endpoints.ListLikeEndpoint,
		DecodeHTTPListLikeZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/like/list").Handler(httptransport.NewServer(
		endpoints.ListLikeEndpoint,
		DecodeHTTPListLikeOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/comment/").Handler(httptransport.NewServer(
		endpoints.GetCommentEndpoint,
		DecodeHTTPGetCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/comment").Handler(httptransport.NewServer(
		endpoints.GetCommentEndpoint,
		DecodeHTTPGetCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/status/new_recommend/").Handler(httptransport.NewServer(
		endpoints.NewRecommendStatusEndpoint,
		DecodeHTTPNewRecommendStatusZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/status/new_recommend").Handler(httptransport.NewServer(
		endpoints.NewRecommendStatusEndpoint,
		DecodeHTTPNewRecommendStatusOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/create/").Handler(httptransport.NewServer(
		endpoints.CreateCommentEndpoint,
		DecodeHTTPCreateCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/create").Handler(httptransport.NewServer(
		endpoints.CreateCommentEndpoint,
		DecodeHTTPCreateCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/delete/").Handler(httptransport.NewServer(
		endpoints.DeleteCommentEndpoint,
		DecodeHTTPDeleteCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/delete").Handler(httptransport.NewServer(
		endpoints.DeleteCommentEndpoint,
		DecodeHTTPDeleteCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/like/").Handler(httptransport.NewServer(
		endpoints.LikeCommentEndpoint,
		DecodeHTTPLikeCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/like").Handler(httptransport.NewServer(
		endpoints.LikeCommentEndpoint,
		DecodeHTTPLikeCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/comment/unlike/").Handler(httptransport.NewServer(
		endpoints.UnlikeCommentEndpoint,
		DecodeHTTPUnlikeCommentZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/comment/unlike").Handler(httptransport.NewServer(
		endpoints.UnlikeCommentEndpoint,
		DecodeHTTPUnlikeCommentOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/blacklist/list").Handler(httptransport.NewServer(
		endpoints.ListBlacklistEndpoint,
		DecodeHTTPListBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user/blacklist/list").Handler(httptransport.NewServer(
		endpoints.ListBlacklistEndpoint,
		DecodeHTTPListBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/blacklist/create/").Handler(httptransport.NewServer(
		endpoints.CreateBlacklistEndpoint,
		DecodeHTTPCreateBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/blacklist/create").Handler(httptransport.NewServer(
		endpoints.CreateBlacklistEndpoint,
		DecodeHTTPCreateBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/blacklist/delete/").Handler(httptransport.NewServer(
		endpoints.DeleteBlacklistEndpoint,
		DecodeHTTPDeleteBlacklistZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/blacklist/delete").Handler(httptransport.NewServer(
		endpoints.DeleteBlacklistEndpoint,
		DecodeHTTPDeleteBlacklistOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/share/twitter/").Handler(httptransport.NewServer(
		endpoints.ShareTweetUrlEndpoint,
		DecodeHTTPShareTweetUrlZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/share/twitter").Handler(httptransport.NewServer(
		endpoints.ShareTweetUrlEndpoint,
		DecodeHTTPShareTweetUrlOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/twitter/auth/").Handler(httptransport.NewServer(
		endpoints.TwitterAuthEndpoint,
		DecodeHTTPTwitterAuthZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/twitter/auth").Handler(httptransport.NewServer(
		endpoints.TwitterAuthEndpoint,
		DecodeHTTPTwitterAuthOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/airdrop/twitter/").Handler(httptransport.NewServer(
		endpoints.AirdropTwitterEndpoint,
		DecodeHTTPAirdropTwitterZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/airdrop/twitter").Handler(httptransport.NewServer(
		endpoints.AirdropTwitterEndpoint,
		DecodeHTTPAirdropTwitterOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/airdrop/channel/").Handler(httptransport.NewServer(
		endpoints.AirdropChannelEndpoint,
		DecodeHTTPAirdropChannelZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/airdrop/channel").Handler(httptransport.NewServer(
		endpoints.AirdropChannelEndpoint,
		DecodeHTTPAirdropChannelOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/airdrop/create/").Handler(httptransport.NewServer(
		endpoints.CreateAirdropTwitterEndpoint,
		DecodeHTTPCreateAirdropTwitterZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/airdrop/create").Handler(httptransport.NewServer(
		endpoints.CreateAirdropTwitterEndpoint,
		DecodeHTTPCreateAirdropTwitterOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/channel_airdrop/create/").Handler(httptransport.NewServer(
		endpoints.CreateChannelAirdropEndpoint,
		DecodeHTTPCreateChannelAirdropZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/channel_airdrop/create").Handler(httptransport.NewServer(
		endpoints.CreateChannelAirdropEndpoint,
		DecodeHTTPCreateChannelAirdropOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/to_chain/").Handler(httptransport.NewServer(
		endpoints.UserToChainEndpoint,
		DecodeHTTPUserToChainZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user/to_chain").Handler(httptransport.NewServer(
		endpoints.UserToChainEndpoint,
		DecodeHTTPUserToChainOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/channel/info/").Handler(httptransport.NewServer(
		endpoints.ChannelInfoEndpoint,
		DecodeHTTPChannelInfoZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/channel/info").Handler(httptransport.NewServer(
		endpoints.ChannelInfoEndpoint,
		DecodeHTTPChannelInfoOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/channel_user/page/").Handler(httptransport.NewServer(
		endpoints.PageChannelUserEndpoint,
		DecodeHTTPPageChannelUserZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/channel_user/page").Handler(httptransport.NewServer(
		endpoints.PageChannelUserEndpoint,
		DecodeHTTPPageChannelUserOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/channel_user/").Handler(httptransport.NewServer(
		endpoints.GetChannelUserEndpoint,
		DecodeHTTPGetChannelUserZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/channel_user").Handler(httptransport.NewServer(
		endpoints.GetChannelUserEndpoint,
		DecodeHTTPGetChannelUserOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/opensea/single_asset/").Handler(httptransport.NewServer(
		endpoints.GetOpenseaAssetEndpoint,
		DecodeHTTPGetOpenseaAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/opensea/single_asset").Handler(httptransport.NewServer(
		endpoints.GetOpenseaAssetEndpoint,
		DecodeHTTPGetOpenseaAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/opensea/assets/").Handler(httptransport.NewServer(
		endpoints.ListOpenseaAssetEndpoint,
		DecodeHTTPListOpenseaAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/opensea/assets").Handler(httptransport.NewServer(
		endpoints.ListOpenseaAssetEndpoint,
		DecodeHTTPListOpenseaAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/opensea/asset_contract/").Handler(httptransport.NewServer(
		endpoints.GetOpenseaAssetContractEndpoint,
		DecodeHTTPGetOpenseaAssetContractZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/opensea/asset_contract").Handler(httptransport.NewServer(
		endpoints.GetOpenseaAssetContractEndpoint,
		DecodeHTTPGetOpenseaAssetContractOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/nft_asset/page/").Handler(httptransport.NewServer(
		endpoints.PageNftAssetEndpoint,
		DecodeHTTPPageNftAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/nft_asset/page").Handler(httptransport.NewServer(
		endpoints.PageNftAssetEndpoint,
		DecodeHTTPPageNftAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/nft_asset/get/").Handler(httptransport.NewServer(
		endpoints.GetNftAssetEndpoint,
		DecodeHTTPGetNftAssetZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/nft_asset/get").Handler(httptransport.NewServer(
		endpoints.GetNftAssetEndpoint,
		DecodeHTTPGetNftAssetOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/nft_event/page/").Handler(httptransport.NewServer(
		endpoints.PageNftEventEndpoint,
		DecodeHTTPPageNftEventZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/nft_event/page").Handler(httptransport.NewServer(
		endpoints.PageNftEventEndpoint,
		DecodeHTTPPageNftEventOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/config/").Handler(httptransport.NewServer(
		endpoints.UpdateUserConfigEndpoint,
		DecodeHTTPUpdateUserConfigZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/config").Handler(httptransport.NewServer(
		endpoints.UpdateUserConfigEndpoint,
		DecodeHTTPUpdateUserConfigOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("POST").Path("/user/complaint/").Handler(httptransport.NewServer(
		endpoints.ComplaintEndpoint,
		DecodeHTTPComplaintZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("POST").Path("/user/complaint").Handler(httptransport.NewServer(
		endpoints.ComplaintEndpoint,
		DecodeHTTPComplaintOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/user/config/").Handler(httptransport.NewServer(
		endpoints.GetUserConfigEndpoint,
		DecodeHTTPGetUserConfigZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/user/config").Handler(httptransport.NewServer(
		endpoints.GetUserConfigEndpoint,
		DecodeHTTPGetUserConfigOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/nft/update/").Handler(httptransport.NewServer(
		endpoints.UpdateOpenseaNftEndpoint,
		DecodeHTTPUpdateOpenseaNftZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/nft/update").Handler(httptransport.NewServer(
		endpoints.UpdateOpenseaNftEndpoint,
		DecodeHTTPUpdateOpenseaNftOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/twitter/auth_url/").Handler(httptransport.NewServer(
		endpoints.GetTwitterAuthUrlEndpoint,
		DecodeHTTPGetTwitterAuthUrlZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/twitter/auth_url").Handler(httptransport.NewServer(
		endpoints.GetTwitterAuthUrlEndpoint,
		DecodeHTTPGetTwitterAuthUrlOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/airdrop/info/").Handler(httptransport.NewServer(
		endpoints.GetAirdropInfoEndpoint,
		DecodeHTTPGetAirdropInfoZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/airdrop/info").Handler(httptransport.NewServer(
		endpoints.GetAirdropInfoEndpoint,
		DecodeHTTPGetAirdropInfoOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/twitter/callback/").Handler(httptransport.NewServer(
		endpoints.TwitterCallbackEndpoint,
		DecodeHTTPTwitterCallbackZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/twitter/callback").Handler(httptransport.NewServer(
		endpoints.TwitterCallbackEndpoint,
		DecodeHTTPTwitterCallbackOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/twitter/follow/").Handler(httptransport.NewServer(
		endpoints.TwitterFollowEndpoint,
		DecodeHTTPTwitterFollowZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/twitter/follow").Handler(httptransport.NewServer(
		endpoints.TwitterFollowEndpoint,
		DecodeHTTPTwitterFollowOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/airdrop/receive/").Handler(httptransport.NewServer(
		endpoints.ReceiveAirdropEndpoint,
		DecodeHTTPReceiveAirdropZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/airdrop/receive").Handler(httptransport.NewServer(
		endpoints.ReceiveAirdropEndpoint,
		DecodeHTTPReceiveAirdropOneRequest,
		responseEncoder,
		serverOptions...,
	))
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode

// DecodeHTTPSignInZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded signin request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSignInZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SignInRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AuthSignInStrArr, ok := queryParams["auth"]; ok {
		AuthSignInStr := AuthSignInStrArr[0]
		AuthSignIn := AuthSignInStr
		req.Auth = AuthSignIn
	}

	if ReferrerSignInStrArr, ok := queryParams["referrer"]; ok {
		ReferrerSignInStr := ReferrerSignInStrArr[0]
		ReferrerSignIn := ReferrerSignInStr
		req.Referrer = ReferrerSignIn
	}

	return &req, err
}

// DecodeHTTPSignInOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded signin request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSignInOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SignInRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AuthSignInStrArr, ok := queryParams["auth"]; ok {
		AuthSignInStr := AuthSignInStrArr[0]
		AuthSignIn := AuthSignInStr
		req.Auth = AuthSignIn
	}

	if ReferrerSignInStrArr, ok := queryParams["referrer"]; ok {
		ReferrerSignInStr := ReferrerSignInStrArr[0]
		ReferrerSignIn := ReferrerSignInStr
		req.Referrer = ReferrerSignIn
	}

	return &req, err
}

// DecodeHTTPFindUserZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded finduser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindUserZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidFindUserStrArr, ok := queryParams["uid"]; ok {
		UidFindUserStr := UidFindUserStrArr[0]
		UidFindUser, err := strconv.ParseUint(UidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidFindUser from query, queryParams: %v", queryParams))
		}
		req.Uid = UidFindUser
	}

	if CurrentUidFindUserStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidFindUserStr := CurrentUidFindUserStrArr[0]
		CurrentUidFindUser, err := strconv.ParseUint(CurrentUidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidFindUser from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidFindUser
	}

	return &req, err
}

// DecodeHTTPFindUserOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded finduser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindUserOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidFindUserStrArr, ok := queryParams["uid"]; ok {
		UidFindUserStr := UidFindUserStrArr[0]
		UidFindUser, err := strconv.ParseUint(UidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidFindUser from query, queryParams: %v", queryParams))
		}
		req.Uid = UidFindUser
	}

	if CurrentUidFindUserStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidFindUserStr := CurrentUidFindUserStrArr[0]
		CurrentUidFindUser, err := strconv.ParseUint(CurrentUidFindUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidFindUser from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidFindUser
	}

	return &req, err
}

// DecodeHTTPFindMisesUserZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded findmisesuser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindMisesUserZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindMisesUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidFindMisesUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidFindMisesUserStr := MisesidFindMisesUserStrArr[0]
		MisesidFindMisesUser := MisesidFindMisesUserStr
		req.Misesid = MisesidFindMisesUser
	}

	if CurrentUidFindMisesUserStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidFindMisesUserStr := CurrentUidFindMisesUserStrArr[0]
		CurrentUidFindMisesUser, err := strconv.ParseUint(CurrentUidFindMisesUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidFindMisesUser from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidFindMisesUser
	}

	return &req, err
}

// DecodeHTTPFindMisesUserOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded findmisesuser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindMisesUserOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindMisesUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidFindMisesUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidFindMisesUserStr := MisesidFindMisesUserStrArr[0]
		MisesidFindMisesUser := MisesidFindMisesUserStr
		req.Misesid = MisesidFindMisesUser
	}

	if CurrentUidFindMisesUserStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidFindMisesUserStr := CurrentUidFindMisesUserStrArr[0]
		CurrentUidFindMisesUser, err := strconv.ParseUint(CurrentUidFindMisesUserStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidFindMisesUser from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidFindMisesUser
	}

	return &req, err
}

// DecodeHTTPUpdateUserProfileZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserprofile request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserProfileZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserProfileRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserProfileOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserprofile request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserProfileOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserProfileRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserAvatarZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuseravatar request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserAvatarZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserAvatarRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserAvatarOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuseravatar request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserAvatarOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserAvatarRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserNameZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateusername request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserNameZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserNameRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserNameOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateusername request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserNameOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserNameRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updatestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updatestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListLikeStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListLikeStatusStrArr, ok := queryParams["uid"]; ok {
		UidListLikeStatusStr := UidListLikeStatusStrArr[0]
		UidListLikeStatus, err := strconv.ParseUint(UidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListLikeStatus
	}

	if CurrentUidListLikeStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListLikeStatusStr := CurrentUidListLikeStatusStrArr[0]
		CurrentUidListLikeStatus, err := strconv.ParseUint(CurrentUidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListLikeStatus
	}

	if PaginatorListLikeStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStatusStr := PaginatorListLikeStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLikeStatus from %v", PaginatorListLikeStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPListLikeStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlikestatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListLikeStatusStrArr, ok := queryParams["uid"]; ok {
		UidListLikeStatusStr := UidListLikeStatusStrArr[0]
		UidListLikeStatus, err := strconv.ParseUint(UidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListLikeStatus
	}

	if CurrentUidListLikeStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListLikeStatusStr := CurrentUidListLikeStatusStrArr[0]
		CurrentUidListLikeStatus, err := strconv.ParseUint(CurrentUidListLikeStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListLikeStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListLikeStatus
	}

	if PaginatorListLikeStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStatusStr := PaginatorListLikeStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLikeStatus from %v", PaginatorListLikeStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPLikeNftAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeNftAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeNftAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeNftAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeNftAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeNftAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeNftAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeNftAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnLikeNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPGetStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetStatusStr := CurrentUidGetStatusStrArr[0]
		CurrentUidGetStatus, err := strconv.ParseUint(CurrentUidGetStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetStatus
	}

	if StatusidGetStatusStrArr, ok := queryParams["statusid"]; ok {
		StatusidGetStatusStr := StatusidGetStatusStrArr[0]
		StatusidGetStatus := StatusidGetStatusStr
		req.Statusid = StatusidGetStatus
	}

	return &req, err
}

// DecodeHTTPGetStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetStatusStr := CurrentUidGetStatusStrArr[0]
		CurrentUidGetStatus, err := strconv.ParseUint(CurrentUidGetStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetStatus
	}

	if StatusidGetStatusStrArr, ok := queryParams["statusid"]; ok {
		StatusidGetStatusStr := StatusidGetStatusStrArr[0]
		StatusidGetStatus := StatusidGetStatusStr
		req.Statusid = StatusidGetStatus
	}

	return &req, err
}

// DecodeHTTPListStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded liststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListStatusStr := CurrentUidListStatusStrArr[0]
		CurrentUidListStatus, err := strconv.ParseUint(CurrentUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListStatus
	}

	if TargetUidListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListStatusStr := TargetUidListStatusStrArr[0]
		TargetUidListStatus, err := strconv.ParseUint(TargetUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListStatus
	}

	if ParentIdListStatusStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListStatusStr := ParentIdListStatusStrArr[0]
		ParentIdListStatus := ParentIdListStatusStr
		req.ParentId = ParentIdListStatus
	}

	if FromTypesListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListStatusStr := FromTypesListStatusStrArr[0]

		var FromTypesListStatus []string
		if len(FromTypesListStatusStrArr) > 1 {
			FromTypesListStatus = FromTypesListStatusStrArr
		} else {
			FromTypesListStatus = strings.Split(FromTypesListStatusStr, ",")
		}
		req.FromTypes = FromTypesListStatus
	}

	if PaginatorListStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListStatusStr := PaginatorListStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListStatus from %v", PaginatorListStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPListStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded liststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListStatusStr := CurrentUidListStatusStrArr[0]
		CurrentUidListStatus, err := strconv.ParseUint(CurrentUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListStatus
	}

	if TargetUidListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListStatusStr := TargetUidListStatusStrArr[0]
		TargetUidListStatus, err := strconv.ParseUint(TargetUidListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListStatus
	}

	if ParentIdListStatusStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListStatusStr := ParentIdListStatusStrArr[0]
		ParentIdListStatus := ParentIdListStatusStr
		req.ParentId = ParentIdListStatus
	}

	if FromTypesListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListStatusStr := FromTypesListStatusStrArr[0]

		var FromTypesListStatus []string
		if len(FromTypesListStatusStrArr) > 1 {
			FromTypesListStatus = FromTypesListStatusStrArr
		} else {
			FromTypesListStatus = strings.Split(FromTypesListStatusStr, ",")
		}
		req.FromTypes = FromTypesListStatus
	}

	if PaginatorListStatusStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListStatusStr := PaginatorListStatusStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListStatusStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListStatus from %v", PaginatorListStatusStr)
		}

	}

	return &req, err
}

// DecodeHTTPNewListStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded newliststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPNewListStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.NewListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidNewListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidNewListStatusStr := CurrentUidNewListStatusStrArr[0]
		CurrentUidNewListStatus, err := strconv.ParseUint(CurrentUidNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidNewListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidNewListStatus
	}

	if TargetUidNewListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidNewListStatusStr := TargetUidNewListStatusStrArr[0]
		TargetUidNewListStatus, err := strconv.ParseUint(TargetUidNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidNewListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidNewListStatus
	}

	if IdsNewListStatusStrArr, ok := queryParams["ids"]; ok {
		IdsNewListStatusStr := IdsNewListStatusStrArr[0]

		var IdsNewListStatus []string
		if len(IdsNewListStatusStrArr) > 1 {
			IdsNewListStatus = IdsNewListStatusStrArr
		} else {
			IdsNewListStatus = strings.Split(IdsNewListStatusStr, ",")
		}
		req.Ids = IdsNewListStatus
	}

	if ListNumNewListStatusStrArr, ok := queryParams["list_num"]; ok {
		ListNumNewListStatusStr := ListNumNewListStatusStrArr[0]
		ListNumNewListStatus, err := strconv.ParseUint(ListNumNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ListNumNewListStatus from query, queryParams: %v", queryParams))
		}
		req.ListNum = ListNumNewListStatus
	}

	if FromTypesNewListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesNewListStatusStr := FromTypesNewListStatusStrArr[0]

		var FromTypesNewListStatus []string
		if len(FromTypesNewListStatusStrArr) > 1 {
			FromTypesNewListStatus = FromTypesNewListStatusStrArr
		} else {
			FromTypesNewListStatus = strings.Split(FromTypesNewListStatusStr, ",")
		}
		req.FromTypes = FromTypesNewListStatus
	}

	return &req, err
}

// DecodeHTTPNewListStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded newliststatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPNewListStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.NewListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidNewListStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidNewListStatusStr := CurrentUidNewListStatusStrArr[0]
		CurrentUidNewListStatus, err := strconv.ParseUint(CurrentUidNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidNewListStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidNewListStatus
	}

	if TargetUidNewListStatusStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidNewListStatusStr := TargetUidNewListStatusStrArr[0]
		TargetUidNewListStatus, err := strconv.ParseUint(TargetUidNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidNewListStatus from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidNewListStatus
	}

	if IdsNewListStatusStrArr, ok := queryParams["ids"]; ok {
		IdsNewListStatusStr := IdsNewListStatusStrArr[0]

		var IdsNewListStatus []string
		if len(IdsNewListStatusStrArr) > 1 {
			IdsNewListStatus = IdsNewListStatusStrArr
		} else {
			IdsNewListStatus = strings.Split(IdsNewListStatusStr, ",")
		}
		req.Ids = IdsNewListStatus
	}

	if ListNumNewListStatusStrArr, ok := queryParams["list_num"]; ok {
		ListNumNewListStatusStr := ListNumNewListStatusStrArr[0]
		ListNumNewListStatus, err := strconv.ParseUint(ListNumNewListStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ListNumNewListStatus from query, queryParams: %v", queryParams))
		}
		req.ListNum = ListNumNewListStatus
	}

	if FromTypesNewListStatusStrArr, ok := queryParams["from_types"]; ok {
		FromTypesNewListStatusStr := FromTypesNewListStatusStrArr[0]

		var FromTypesNewListStatus []string
		if len(FromTypesNewListStatusStrArr) > 1 {
			FromTypesNewListStatus = FromTypesNewListStatusStrArr
		} else {
			FromTypesNewListStatus = strings.Split(FromTypesNewListStatusStr, ",")
		}
		req.FromTypes = FromTypesNewListStatus
	}

	return &req, err
}

// DecodeHTTPListRecommendedZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrecommended request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRecommendedZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRecommendedStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRecommendedStr := CurrentUidListRecommendedStrArr[0]
		CurrentUidListRecommended, err := strconv.ParseUint(CurrentUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRecommended
	}

	if TargetUidListRecommendedStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListRecommendedStr := TargetUidListRecommendedStrArr[0]
		TargetUidListRecommended, err := strconv.ParseUint(TargetUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListRecommended
	}

	if ParentIdListRecommendedStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListRecommendedStr := ParentIdListRecommendedStrArr[0]
		ParentIdListRecommended := ParentIdListRecommendedStr
		req.ParentId = ParentIdListRecommended
	}

	if FromTypesListRecommendedStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListRecommendedStr := FromTypesListRecommendedStrArr[0]

		var FromTypesListRecommended []string
		if len(FromTypesListRecommendedStrArr) > 1 {
			FromTypesListRecommended = FromTypesListRecommendedStrArr
		} else {
			FromTypesListRecommended = strings.Split(FromTypesListRecommendedStr, ",")
		}
		req.FromTypes = FromTypesListRecommended
	}

	if PaginatorListRecommendedStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRecommendedStr := PaginatorListRecommendedStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRecommendedStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRecommended from %v", PaginatorListRecommendedStr)
		}

	}

	return &req, err
}

// DecodeHTTPListRecommendedOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrecommended request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRecommendedOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRecommendedStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRecommendedStr := CurrentUidListRecommendedStrArr[0]
		CurrentUidListRecommended, err := strconv.ParseUint(CurrentUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRecommended
	}

	if TargetUidListRecommendedStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListRecommendedStr := TargetUidListRecommendedStrArr[0]
		TargetUidListRecommended, err := strconv.ParseUint(TargetUidListRecommendedStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListRecommended from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListRecommended
	}

	if ParentIdListRecommendedStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListRecommendedStr := ParentIdListRecommendedStrArr[0]
		ParentIdListRecommended := ParentIdListRecommendedStr
		req.ParentId = ParentIdListRecommended
	}

	if FromTypesListRecommendedStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListRecommendedStr := FromTypesListRecommendedStrArr[0]

		var FromTypesListRecommended []string
		if len(FromTypesListRecommendedStrArr) > 1 {
			FromTypesListRecommended = FromTypesListRecommendedStrArr
		} else {
			FromTypesListRecommended = strings.Split(FromTypesListRecommendedStr, ",")
		}
		req.FromTypes = FromTypesListRecommended
	}

	if PaginatorListRecommendedStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRecommendedStr := PaginatorListRecommendedStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRecommendedStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRecommended from %v", PaginatorListRecommendedStr)
		}

	}

	return &req, err
}

// DecodeHTTPListUserTimelineZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listusertimeline request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListUserTimelineZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListUserTimelineStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListUserTimelineStr := CurrentUidListUserTimelineStrArr[0]
		CurrentUidListUserTimeline, err := strconv.ParseUint(CurrentUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListUserTimeline
	}

	if TargetUidListUserTimelineStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListUserTimelineStr := TargetUidListUserTimelineStrArr[0]
		TargetUidListUserTimeline, err := strconv.ParseUint(TargetUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListUserTimeline
	}

	if ParentIdListUserTimelineStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListUserTimelineStr := ParentIdListUserTimelineStrArr[0]
		ParentIdListUserTimeline := ParentIdListUserTimelineStr
		req.ParentId = ParentIdListUserTimeline
	}

	if FromTypesListUserTimelineStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListUserTimelineStr := FromTypesListUserTimelineStrArr[0]

		var FromTypesListUserTimeline []string
		if len(FromTypesListUserTimelineStrArr) > 1 {
			FromTypesListUserTimeline = FromTypesListUserTimelineStrArr
		} else {
			FromTypesListUserTimeline = strings.Split(FromTypesListUserTimelineStr, ",")
		}
		req.FromTypes = FromTypesListUserTimeline
	}

	if PaginatorListUserTimelineStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListUserTimelineStr := PaginatorListUserTimelineStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListUserTimelineStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListUserTimeline from %v", PaginatorListUserTimelineStr)
		}

	}

	return &req, err
}

// DecodeHTTPListUserTimelineOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listusertimeline request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListUserTimelineOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListUserTimelineStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListUserTimelineStr := CurrentUidListUserTimelineStrArr[0]
		CurrentUidListUserTimeline, err := strconv.ParseUint(CurrentUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListUserTimeline
	}

	if TargetUidListUserTimelineStrArr, ok := queryParams["target_uid"]; ok {
		TargetUidListUserTimelineStr := TargetUidListUserTimelineStrArr[0]
		TargetUidListUserTimeline, err := strconv.ParseUint(TargetUidListUserTimelineStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting TargetUidListUserTimeline from query, queryParams: %v", queryParams))
		}
		req.TargetUid = TargetUidListUserTimeline
	}

	if ParentIdListUserTimelineStrArr, ok := queryParams["parent_id"]; ok {
		ParentIdListUserTimelineStr := ParentIdListUserTimelineStrArr[0]
		ParentIdListUserTimeline := ParentIdListUserTimelineStr
		req.ParentId = ParentIdListUserTimeline
	}

	if FromTypesListUserTimelineStrArr, ok := queryParams["from_types"]; ok {
		FromTypesListUserTimelineStr := FromTypesListUserTimelineStrArr[0]

		var FromTypesListUserTimeline []string
		if len(FromTypesListUserTimelineStrArr) > 1 {
			FromTypesListUserTimeline = FromTypesListUserTimelineStrArr
		} else {
			FromTypesListUserTimeline = strings.Split(FromTypesListUserTimelineStr, ",")
		}
		req.FromTypes = FromTypesListUserTimeline
	}

	if PaginatorListUserTimelineStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListUserTimelineStr := PaginatorListUserTimelineStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListUserTimelineStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListUserTimeline from %v", PaginatorListUserTimelineStr)
		}

	}

	return &req, err
}

// DecodeHTTPLatestFollowingZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded latestfollowing request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLatestFollowingZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LatestFollowingRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidLatestFollowingStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidLatestFollowingStr := CurrentUidLatestFollowingStrArr[0]
		CurrentUidLatestFollowing, err := strconv.ParseUint(CurrentUidLatestFollowingStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidLatestFollowing from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidLatestFollowing
	}

	return &req, err
}

// DecodeHTTPLatestFollowingOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded latestfollowing request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLatestFollowingOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LatestFollowingRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidLatestFollowingStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidLatestFollowingStr := CurrentUidLatestFollowingStrArr[0]
		CurrentUidLatestFollowing, err := strconv.ParseUint(CurrentUidLatestFollowingStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidLatestFollowing from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidLatestFollowing
	}

	return &req, err
}

// DecodeHTTPListRelationshipZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrelationship request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRelationshipZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListRelationshipRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRelationshipStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRelationshipStr := CurrentUidListRelationshipStrArr[0]
		CurrentUidListRelationship, err := strconv.ParseUint(CurrentUidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRelationship from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRelationship
	}

	if UidListRelationshipStrArr, ok := queryParams["uid"]; ok {
		UidListRelationshipStr := UidListRelationshipStrArr[0]
		UidListRelationship, err := strconv.ParseUint(UidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListRelationship from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListRelationship
	}

	if RelationTypeListRelationshipStrArr, ok := queryParams["relation_type"]; ok {
		RelationTypeListRelationshipStr := RelationTypeListRelationshipStrArr[0]
		RelationTypeListRelationship := RelationTypeListRelationshipStr
		req.RelationType = RelationTypeListRelationship
	}

	if PaginatorListRelationshipStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRelationshipStr := PaginatorListRelationshipStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRelationshipStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRelationship from %v", PaginatorListRelationshipStr)
		}

	}

	return &req, err
}

// DecodeHTTPListRelationshipOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listrelationship request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRelationshipOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListRelationshipRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListRelationshipStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListRelationshipStr := CurrentUidListRelationshipStrArr[0]
		CurrentUidListRelationship, err := strconv.ParseUint(CurrentUidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListRelationship from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListRelationship
	}

	if UidListRelationshipStrArr, ok := queryParams["uid"]; ok {
		UidListRelationshipStr := UidListRelationshipStrArr[0]
		UidListRelationship, err := strconv.ParseUint(UidListRelationshipStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListRelationship from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListRelationship
	}

	if RelationTypeListRelationshipStrArr, ok := queryParams["relation_type"]; ok {
		RelationTypeListRelationshipStr := RelationTypeListRelationshipStrArr[0]
		RelationTypeListRelationship := RelationTypeListRelationshipStr
		req.RelationType = RelationTypeListRelationship
	}

	if PaginatorListRelationshipStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListRelationshipStr := PaginatorListRelationshipStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListRelationshipStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListRelationship from %v", PaginatorListRelationshipStr)
		}

	}

	return &req, err
}

// DecodeHTTPFollowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded follow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFollowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPFollowOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded follow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFollowOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnFollowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnFollowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnFollowOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnFollowOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListMessageZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListMessageZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListMessageStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListMessageStr := CurrentUidListMessageStrArr[0]
		CurrentUidListMessage, err := strconv.ParseUint(CurrentUidListMessageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListMessage from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListMessage
	}

	if StateListMessageStrArr, ok := queryParams["state"]; ok {
		StateListMessageStr := StateListMessageStrArr[0]
		StateListMessage := StateListMessageStr
		req.State = StateListMessage
	}

	if PaginatorListMessageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListMessageStr := PaginatorListMessageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListMessageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListMessage from %v", PaginatorListMessageStr)
		}

	}

	return &req, err
}

// DecodeHTTPListMessageOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListMessageOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListMessageStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListMessageStr := CurrentUidListMessageStrArr[0]
		CurrentUidListMessage, err := strconv.ParseUint(CurrentUidListMessageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListMessage from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListMessage
	}

	if StateListMessageStrArr, ok := queryParams["state"]; ok {
		StateListMessageStr := StateListMessageStrArr[0]
		StateListMessage := StateListMessageStr
		req.State = StateListMessage
	}

	if PaginatorListMessageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListMessageStr := PaginatorListMessageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListMessageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListMessage from %v", PaginatorListMessageStr)
		}

	}

	return &req, err
}

// DecodeHTTPReadMessageZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded readmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReadMessageZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReadMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPReadMessageOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded readmessage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReadMessageOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReadMessageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPGetMessageSummaryZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getmessagesummary request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetMessageSummaryZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetMessageSummaryRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetMessageSummaryStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetMessageSummaryStr := CurrentUidGetMessageSummaryStrArr[0]
		CurrentUidGetMessageSummary, err := strconv.ParseUint(CurrentUidGetMessageSummaryStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetMessageSummary from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetMessageSummary
	}

	return &req, err
}

// DecodeHTTPGetMessageSummaryOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getmessagesummary request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetMessageSummaryOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetMessageSummaryRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetMessageSummaryStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetMessageSummaryStr := CurrentUidGetMessageSummaryStrArr[0]
		CurrentUidGetMessageSummary, err := strconv.ParseUint(CurrentUidGetMessageSummaryStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetMessageSummary from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetMessageSummary
	}

	return &req, err
}

// DecodeHTTPListCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListCommentStr := CurrentUidListCommentStrArr[0]
		CurrentUidListComment, err := strconv.ParseUint(CurrentUidListCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListComment
	}

	if StatusIdListCommentStrArr, ok := queryParams["status_id"]; ok {
		StatusIdListCommentStr := StatusIdListCommentStrArr[0]
		StatusIdListComment := StatusIdListCommentStr
		req.StatusId = StatusIdListComment
	}

	if TopicIdListCommentStrArr, ok := queryParams["topic_id"]; ok {
		TopicIdListCommentStr := TopicIdListCommentStrArr[0]
		TopicIdListComment := TopicIdListCommentStr
		req.TopicId = TopicIdListComment
	}

	if PaginatorListCommentStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListCommentStr := PaginatorListCommentStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListCommentStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListComment from %v", PaginatorListCommentStr)
		}

	}

	if NftAssetIdListCommentStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdListCommentStr := NftAssetIdListCommentStrArr[0]
		NftAssetIdListComment := NftAssetIdListCommentStr
		req.NftAssetId = NftAssetIdListComment
	}

	return &req, err
}

// DecodeHTTPListCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListCommentStr := CurrentUidListCommentStrArr[0]
		CurrentUidListComment, err := strconv.ParseUint(CurrentUidListCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListComment
	}

	if StatusIdListCommentStrArr, ok := queryParams["status_id"]; ok {
		StatusIdListCommentStr := StatusIdListCommentStrArr[0]
		StatusIdListComment := StatusIdListCommentStr
		req.StatusId = StatusIdListComment
	}

	if TopicIdListCommentStrArr, ok := queryParams["topic_id"]; ok {
		TopicIdListCommentStr := TopicIdListCommentStrArr[0]
		TopicIdListComment := TopicIdListCommentStr
		req.TopicId = TopicIdListComment
	}

	if PaginatorListCommentStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListCommentStr := PaginatorListCommentStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListCommentStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListComment from %v", PaginatorListCommentStr)
		}

	}

	if NftAssetIdListCommentStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdListCommentStr := NftAssetIdListCommentStrArr[0]
		NftAssetIdListComment := NftAssetIdListCommentStr
		req.NftAssetId = NftAssetIdListComment
	}

	return &req, err
}

// DecodeHTTPListLikeZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlike request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListLikeStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListLikeStr := CurrentUidListLikeStrArr[0]
		CurrentUidListLike, err := strconv.ParseUint(CurrentUidListLikeStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListLike from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListLike
	}

	if TargerIdListLikeStrArr, ok := queryParams["targer_id"]; ok {
		TargerIdListLikeStr := TargerIdListLikeStrArr[0]
		TargerIdListLike := TargerIdListLikeStr
		req.TargerId = TargerIdListLike
	}

	if PaginatorListLikeStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStr := PaginatorListLikeStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLike from %v", PaginatorListLikeStr)
		}

	}

	return &req, err
}

// DecodeHTTPListLikeOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listlike request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListLikeOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListLikeUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidListLikeStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListLikeStr := CurrentUidListLikeStrArr[0]
		CurrentUidListLike, err := strconv.ParseUint(CurrentUidListLikeStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListLike from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListLike
	}

	if TargerIdListLikeStrArr, ok := queryParams["targer_id"]; ok {
		TargerIdListLikeStr := TargerIdListLikeStrArr[0]
		TargerIdListLike := TargerIdListLikeStr
		req.TargerId = TargerIdListLike
	}

	if PaginatorListLikeStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListLikeStr := PaginatorListLikeStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListLikeStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListLike from %v", PaginatorListLikeStr)
		}

	}

	return &req, err
}

// DecodeHTTPGetCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetCommentStr := CurrentUidGetCommentStrArr[0]
		CurrentUidGetComment, err := strconv.ParseUint(CurrentUidGetCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetComment
	}

	if CommentIdGetCommentStrArr, ok := queryParams["comment_id"]; ok {
		CommentIdGetCommentStr := CommentIdGetCommentStrArr[0]
		CommentIdGetComment := CommentIdGetCommentStr
		req.CommentId = CommentIdGetComment
	}

	return &req, err
}

// DecodeHTTPGetCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetCommentStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetCommentStr := CurrentUidGetCommentStrArr[0]
		CurrentUidGetComment, err := strconv.ParseUint(CurrentUidGetCommentStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetComment from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetComment
	}

	if CommentIdGetCommentStrArr, ok := queryParams["comment_id"]; ok {
		CommentIdGetCommentStr := CommentIdGetCommentStrArr[0]
		CommentIdGetComment := CommentIdGetCommentStr
		req.CommentId = CommentIdGetComment
	}

	return &req, err
}

// DecodeHTTPNewRecommendStatusZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded newrecommendstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPNewRecommendStatusZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.NewRecommendStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidNewRecommendStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidNewRecommendStatusStr := CurrentUidNewRecommendStatusStrArr[0]
		CurrentUidNewRecommendStatus, err := strconv.ParseUint(CurrentUidNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidNewRecommendStatus
	}

	if LastRecommendTimeNewRecommendStatusStrArr, ok := queryParams["last_recommend_time"]; ok {
		LastRecommendTimeNewRecommendStatusStr := LastRecommendTimeNewRecommendStatusStrArr[0]
		LastRecommendTimeNewRecommendStatus, err := strconv.ParseInt(LastRecommendTimeNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LastRecommendTimeNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.LastRecommendTime = LastRecommendTimeNewRecommendStatus
	}

	if LastCommonTimeNewRecommendStatusStrArr, ok := queryParams["last_common_time"]; ok {
		LastCommonTimeNewRecommendStatusStr := LastCommonTimeNewRecommendStatusStrArr[0]
		LastCommonTimeNewRecommendStatus, err := strconv.ParseInt(LastCommonTimeNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LastCommonTimeNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.LastCommonTime = LastCommonTimeNewRecommendStatus
	}

	return &req, err
}

// DecodeHTTPNewRecommendStatusOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded newrecommendstatus request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPNewRecommendStatusOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.NewRecommendStatusRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidNewRecommendStatusStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidNewRecommendStatusStr := CurrentUidNewRecommendStatusStrArr[0]
		CurrentUidNewRecommendStatus, err := strconv.ParseUint(CurrentUidNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidNewRecommendStatus
	}

	if LastRecommendTimeNewRecommendStatusStrArr, ok := queryParams["last_recommend_time"]; ok {
		LastRecommendTimeNewRecommendStatusStr := LastRecommendTimeNewRecommendStatusStrArr[0]
		LastRecommendTimeNewRecommendStatus, err := strconv.ParseInt(LastRecommendTimeNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LastRecommendTimeNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.LastRecommendTime = LastRecommendTimeNewRecommendStatus
	}

	if LastCommonTimeNewRecommendStatusStrArr, ok := queryParams["last_common_time"]; ok {
		LastCommonTimeNewRecommendStatusStr := LastCommonTimeNewRecommendStatusStrArr[0]
		LastCommonTimeNewRecommendStatus, err := strconv.ParseInt(LastCommonTimeNewRecommendStatusStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LastCommonTimeNewRecommendStatus from query, queryParams: %v", queryParams))
		}
		req.LastCommonTime = LastCommonTimeNewRecommendStatus
	}

	return &req, err
}

// DecodeHTTPCreateCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createcomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deletecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPLikeCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded likecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLikeCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.LikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeCommentZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeCommentZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnlikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUnlikeCommentOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded unlikecomment request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUnlikeCommentOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UnlikeCommentRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPListBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListBlacklistStrArr, ok := queryParams["uid"]; ok {
		UidListBlacklistStr := UidListBlacklistStrArr[0]
		UidListBlacklist, err := strconv.ParseUint(UidListBlacklistStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListBlacklist from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListBlacklist
	}

	if PaginatorListBlacklistStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListBlacklistStr := PaginatorListBlacklistStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListBlacklistStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListBlacklist from %v", PaginatorListBlacklistStr)
		}

	}

	return &req, err
}

// DecodeHTTPListBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if UidListBlacklistStrArr, ok := queryParams["uid"]; ok {
		UidListBlacklistStr := UidListBlacklistStrArr[0]
		UidListBlacklist, err := strconv.ParseUint(UidListBlacklistStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidListBlacklist from query, queryParams: %v", queryParams))
		}
		req.Uid = UidListBlacklist
	}

	if PaginatorListBlacklistStrArr, ok := queryParams["paginator"]; ok {
		PaginatorListBlacklistStr := PaginatorListBlacklistStrArr[0]

		err = json.Unmarshal([]byte(PaginatorListBlacklistStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorListBlacklist from %v", PaginatorListBlacklistStr)
		}

	}

	return &req, err
}

// DecodeHTTPCreateBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteBlacklistZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deleteblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteBlacklistZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPDeleteBlacklistOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded deleteblacklist request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteBlacklistOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DeleteBlacklistRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPShareTweetUrlZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded sharetweeturl request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPShareTweetUrlZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ShareTweetUrlRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidShareTweetUrlStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidShareTweetUrlStr := CurrentUidShareTweetUrlStrArr[0]
		CurrentUidShareTweetUrl, err := strconv.ParseUint(CurrentUidShareTweetUrlStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidShareTweetUrl from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidShareTweetUrl
	}

	return &req, err
}

// DecodeHTTPShareTweetUrlOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded sharetweeturl request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPShareTweetUrlOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ShareTweetUrlRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidShareTweetUrlStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidShareTweetUrlStr := CurrentUidShareTweetUrlStrArr[0]
		CurrentUidShareTweetUrl, err := strconv.ParseUint(CurrentUidShareTweetUrlStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidShareTweetUrl from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidShareTweetUrl
	}

	return &req, err
}

// DecodeHTTPTwitterAuthZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twitterauth request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterAuthZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterAuthRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPTwitterAuthOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twitterauth request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterAuthOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterAuthRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPAirdropTwitterZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded airdroptwitter request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPAirdropTwitterZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.AirdropTwitterRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidAirdropTwitterStrArr, ok := queryParams["misesid"]; ok {
		MisesidAirdropTwitterStr := MisesidAirdropTwitterStrArr[0]
		MisesidAirdropTwitter := MisesidAirdropTwitterStr
		req.Misesid = MisesidAirdropTwitter
	}

	return &req, err
}

// DecodeHTTPAirdropTwitterOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded airdroptwitter request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPAirdropTwitterOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.AirdropTwitterRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidAirdropTwitterStrArr, ok := queryParams["misesid"]; ok {
		MisesidAirdropTwitterStr := MisesidAirdropTwitterStrArr[0]
		MisesidAirdropTwitter := MisesidAirdropTwitterStr
		req.Misesid = MisesidAirdropTwitter
	}

	return &req, err
}

// DecodeHTTPAirdropChannelZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded airdropchannel request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPAirdropChannelZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.AirdropChannelRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPAirdropChannelOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded airdropchannel request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPAirdropChannelOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.AirdropChannelRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateAirdropTwitterZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createairdroptwitter request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateAirdropTwitterZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateAirdropTwitterRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateAirdropTwitterOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createairdroptwitter request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateAirdropTwitterOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateAirdropTwitterRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateChannelAirdropZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createchannelairdrop request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateChannelAirdropZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateChannelAirdropRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPCreateChannelAirdropOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded createchannelairdrop request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateChannelAirdropOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.CreateChannelAirdropRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUserToChainZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded usertochain request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUserToChainZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UserToChainRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUserToChainOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded usertochain request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUserToChainOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UserToChainRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPChannelInfoZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded channelinfo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPChannelInfoZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ChannelInfoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidChannelInfoStrArr, ok := queryParams["misesid"]; ok {
		MisesidChannelInfoStr := MisesidChannelInfoStrArr[0]
		MisesidChannelInfo := MisesidChannelInfoStr
		req.Misesid = MisesidChannelInfo
	}

	if TypeChannelInfoStrArr, ok := queryParams["type"]; ok {
		TypeChannelInfoStr := TypeChannelInfoStrArr[0]
		TypeChannelInfo := TypeChannelInfoStr
		req.Type = TypeChannelInfo
	}

	if MediumChannelInfoStrArr, ok := queryParams["medium"]; ok {
		MediumChannelInfoStr := MediumChannelInfoStrArr[0]
		MediumChannelInfo := MediumChannelInfoStr
		req.Medium = MediumChannelInfo
	}

	return &req, err
}

// DecodeHTTPChannelInfoOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded channelinfo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPChannelInfoOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ChannelInfoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidChannelInfoStrArr, ok := queryParams["misesid"]; ok {
		MisesidChannelInfoStr := MisesidChannelInfoStrArr[0]
		MisesidChannelInfo := MisesidChannelInfoStr
		req.Misesid = MisesidChannelInfo
	}

	if TypeChannelInfoStrArr, ok := queryParams["type"]; ok {
		TypeChannelInfoStr := TypeChannelInfoStrArr[0]
		TypeChannelInfo := TypeChannelInfoStr
		req.Type = TypeChannelInfo
	}

	if MediumChannelInfoStrArr, ok := queryParams["medium"]; ok {
		MediumChannelInfoStr := MediumChannelInfoStrArr[0]
		MediumChannelInfo := MediumChannelInfoStr
		req.Medium = MediumChannelInfo
	}

	return &req, err
}

// DecodeHTTPPageChannelUserZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagechanneluser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageChannelUserZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageChannelUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidPageChannelUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidPageChannelUserStr := MisesidPageChannelUserStrArr[0]
		MisesidPageChannelUser := MisesidPageChannelUserStr
		req.Misesid = MisesidPageChannelUser
	}

	if PaginatorPageChannelUserStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageChannelUserStr := PaginatorPageChannelUserStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageChannelUserStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageChannelUser from %v", PaginatorPageChannelUserStr)
		}

	}

	return &req, err
}

// DecodeHTTPPageChannelUserOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagechanneluser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageChannelUserOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageChannelUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidPageChannelUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidPageChannelUserStr := MisesidPageChannelUserStrArr[0]
		MisesidPageChannelUser := MisesidPageChannelUserStr
		req.Misesid = MisesidPageChannelUser
	}

	if PaginatorPageChannelUserStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageChannelUserStr := PaginatorPageChannelUserStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageChannelUserStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageChannelUser from %v", PaginatorPageChannelUserStr)
		}

	}

	return &req, err
}

// DecodeHTTPGetChannelUserZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getchanneluser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetChannelUserZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetChannelUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidGetChannelUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidGetChannelUserStr := MisesidGetChannelUserStrArr[0]
		MisesidGetChannelUser := MisesidGetChannelUserStr
		req.Misesid = MisesidGetChannelUser
	}

	return &req, err
}

// DecodeHTTPGetChannelUserOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getchanneluser request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetChannelUserOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetChannelUserRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if MisesidGetChannelUserStrArr, ok := queryParams["misesid"]; ok {
		MisesidGetChannelUserStr := MisesidGetChannelUserStrArr[0]
		MisesidGetChannelUser := MisesidGetChannelUserStr
		req.Misesid = MisesidGetChannelUser
	}

	return &req, err
}

// DecodeHTTPGetOpenseaAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getopenseaasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetOpenseaAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetOpenseaAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AssetContractAddressGetOpenseaAssetStrArr, ok := queryParams["asset_contract_address"]; ok {
		AssetContractAddressGetOpenseaAssetStr := AssetContractAddressGetOpenseaAssetStrArr[0]
		AssetContractAddressGetOpenseaAsset := AssetContractAddressGetOpenseaAssetStr
		req.AssetContractAddress = AssetContractAddressGetOpenseaAsset
	}

	if TokenIdGetOpenseaAssetStrArr, ok := queryParams["token_id"]; ok {
		TokenIdGetOpenseaAssetStr := TokenIdGetOpenseaAssetStrArr[0]
		TokenIdGetOpenseaAsset := TokenIdGetOpenseaAssetStr
		req.TokenId = TokenIdGetOpenseaAsset
	}

	if AccountAddressGetOpenseaAssetStrArr, ok := queryParams["account_address"]; ok {
		AccountAddressGetOpenseaAssetStr := AccountAddressGetOpenseaAssetStrArr[0]
		AccountAddressGetOpenseaAsset := AccountAddressGetOpenseaAssetStr
		req.AccountAddress = AccountAddressGetOpenseaAsset
	}

	if IncludeOrdersGetOpenseaAssetStrArr, ok := queryParams["include_orders"]; ok {
		IncludeOrdersGetOpenseaAssetStr := IncludeOrdersGetOpenseaAssetStrArr[0]
		IncludeOrdersGetOpenseaAsset := IncludeOrdersGetOpenseaAssetStr
		req.IncludeOrders = IncludeOrdersGetOpenseaAsset
	}

	if NetworkGetOpenseaAssetStrArr, ok := queryParams["network"]; ok {
		NetworkGetOpenseaAssetStr := NetworkGetOpenseaAssetStrArr[0]
		NetworkGetOpenseaAsset := NetworkGetOpenseaAssetStr
		req.Network = NetworkGetOpenseaAsset
	}

	if CurrentUidGetOpenseaAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetOpenseaAssetStr := CurrentUidGetOpenseaAssetStrArr[0]
		CurrentUidGetOpenseaAsset, err := strconv.ParseUint(CurrentUidGetOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetOpenseaAsset
	}

	return &req, err
}

// DecodeHTTPGetOpenseaAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getopenseaasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetOpenseaAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetOpenseaAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AssetContractAddressGetOpenseaAssetStrArr, ok := queryParams["asset_contract_address"]; ok {
		AssetContractAddressGetOpenseaAssetStr := AssetContractAddressGetOpenseaAssetStrArr[0]
		AssetContractAddressGetOpenseaAsset := AssetContractAddressGetOpenseaAssetStr
		req.AssetContractAddress = AssetContractAddressGetOpenseaAsset
	}

	if TokenIdGetOpenseaAssetStrArr, ok := queryParams["token_id"]; ok {
		TokenIdGetOpenseaAssetStr := TokenIdGetOpenseaAssetStrArr[0]
		TokenIdGetOpenseaAsset := TokenIdGetOpenseaAssetStr
		req.TokenId = TokenIdGetOpenseaAsset
	}

	if AccountAddressGetOpenseaAssetStrArr, ok := queryParams["account_address"]; ok {
		AccountAddressGetOpenseaAssetStr := AccountAddressGetOpenseaAssetStrArr[0]
		AccountAddressGetOpenseaAsset := AccountAddressGetOpenseaAssetStr
		req.AccountAddress = AccountAddressGetOpenseaAsset
	}

	if IncludeOrdersGetOpenseaAssetStrArr, ok := queryParams["include_orders"]; ok {
		IncludeOrdersGetOpenseaAssetStr := IncludeOrdersGetOpenseaAssetStrArr[0]
		IncludeOrdersGetOpenseaAsset := IncludeOrdersGetOpenseaAssetStr
		req.IncludeOrders = IncludeOrdersGetOpenseaAsset
	}

	if NetworkGetOpenseaAssetStrArr, ok := queryParams["network"]; ok {
		NetworkGetOpenseaAssetStr := NetworkGetOpenseaAssetStrArr[0]
		NetworkGetOpenseaAsset := NetworkGetOpenseaAssetStr
		req.Network = NetworkGetOpenseaAsset
	}

	if CurrentUidGetOpenseaAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetOpenseaAssetStr := CurrentUidGetOpenseaAssetStrArr[0]
		CurrentUidGetOpenseaAsset, err := strconv.ParseUint(CurrentUidGetOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetOpenseaAsset
	}

	return &req, err
}

// DecodeHTTPListOpenseaAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listopenseaasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListOpenseaAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListOpenseaAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if OwnerListOpenseaAssetStrArr, ok := queryParams["owner"]; ok {
		OwnerListOpenseaAssetStr := OwnerListOpenseaAssetStrArr[0]
		OwnerListOpenseaAsset := OwnerListOpenseaAssetStr
		req.Owner = OwnerListOpenseaAsset
	}

	if LimitListOpenseaAssetStrArr, ok := queryParams["limit"]; ok {
		LimitListOpenseaAssetStr := LimitListOpenseaAssetStrArr[0]
		LimitListOpenseaAsset, err := strconv.ParseUint(LimitListOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LimitListOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.Limit = LimitListOpenseaAsset
	}

	if CursorListOpenseaAssetStrArr, ok := queryParams["cursor"]; ok {
		CursorListOpenseaAssetStr := CursorListOpenseaAssetStrArr[0]
		CursorListOpenseaAsset := CursorListOpenseaAssetStr
		req.Cursor = CursorListOpenseaAsset
	}

	if NetworkListOpenseaAssetStrArr, ok := queryParams["network"]; ok {
		NetworkListOpenseaAssetStr := NetworkListOpenseaAssetStrArr[0]
		NetworkListOpenseaAsset := NetworkListOpenseaAssetStr
		req.Network = NetworkListOpenseaAsset
	}

	if CurrentUidListOpenseaAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListOpenseaAssetStr := CurrentUidListOpenseaAssetStrArr[0]
		CurrentUidListOpenseaAsset, err := strconv.ParseUint(CurrentUidListOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListOpenseaAsset
	}

	return &req, err
}

// DecodeHTTPListOpenseaAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listopenseaasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListOpenseaAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListOpenseaAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if OwnerListOpenseaAssetStrArr, ok := queryParams["owner"]; ok {
		OwnerListOpenseaAssetStr := OwnerListOpenseaAssetStrArr[0]
		OwnerListOpenseaAsset := OwnerListOpenseaAssetStr
		req.Owner = OwnerListOpenseaAsset
	}

	if LimitListOpenseaAssetStrArr, ok := queryParams["limit"]; ok {
		LimitListOpenseaAssetStr := LimitListOpenseaAssetStrArr[0]
		LimitListOpenseaAsset, err := strconv.ParseUint(LimitListOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LimitListOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.Limit = LimitListOpenseaAsset
	}

	if CursorListOpenseaAssetStrArr, ok := queryParams["cursor"]; ok {
		CursorListOpenseaAssetStr := CursorListOpenseaAssetStrArr[0]
		CursorListOpenseaAsset := CursorListOpenseaAssetStr
		req.Cursor = CursorListOpenseaAsset
	}

	if NetworkListOpenseaAssetStrArr, ok := queryParams["network"]; ok {
		NetworkListOpenseaAssetStr := NetworkListOpenseaAssetStrArr[0]
		NetworkListOpenseaAsset := NetworkListOpenseaAssetStr
		req.Network = NetworkListOpenseaAsset
	}

	if CurrentUidListOpenseaAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidListOpenseaAssetStr := CurrentUidListOpenseaAssetStrArr[0]
		CurrentUidListOpenseaAsset, err := strconv.ParseUint(CurrentUidListOpenseaAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidListOpenseaAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidListOpenseaAsset
	}

	return &req, err
}

// DecodeHTTPGetOpenseaAssetContractZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getopenseaassetcontract request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetOpenseaAssetContractZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetOpenseaAssetContractRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AssetContractAddressGetOpenseaAssetContractStrArr, ok := queryParams["asset_contract_address"]; ok {
		AssetContractAddressGetOpenseaAssetContractStr := AssetContractAddressGetOpenseaAssetContractStrArr[0]
		AssetContractAddressGetOpenseaAssetContract := AssetContractAddressGetOpenseaAssetContractStr
		req.AssetContractAddress = AssetContractAddressGetOpenseaAssetContract
	}

	if TokenIdGetOpenseaAssetContractStrArr, ok := queryParams["token_id"]; ok {
		TokenIdGetOpenseaAssetContractStr := TokenIdGetOpenseaAssetContractStrArr[0]
		TokenIdGetOpenseaAssetContract := TokenIdGetOpenseaAssetContractStr
		req.TokenId = TokenIdGetOpenseaAssetContract
	}

	if AccountAddressGetOpenseaAssetContractStrArr, ok := queryParams["account_address"]; ok {
		AccountAddressGetOpenseaAssetContractStr := AccountAddressGetOpenseaAssetContractStrArr[0]
		AccountAddressGetOpenseaAssetContract := AccountAddressGetOpenseaAssetContractStr
		req.AccountAddress = AccountAddressGetOpenseaAssetContract
	}

	if IncludeOrdersGetOpenseaAssetContractStrArr, ok := queryParams["include_orders"]; ok {
		IncludeOrdersGetOpenseaAssetContractStr := IncludeOrdersGetOpenseaAssetContractStrArr[0]
		IncludeOrdersGetOpenseaAssetContract := IncludeOrdersGetOpenseaAssetContractStr
		req.IncludeOrders = IncludeOrdersGetOpenseaAssetContract
	}

	if NetworkGetOpenseaAssetContractStrArr, ok := queryParams["network"]; ok {
		NetworkGetOpenseaAssetContractStr := NetworkGetOpenseaAssetContractStrArr[0]
		NetworkGetOpenseaAssetContract := NetworkGetOpenseaAssetContractStr
		req.Network = NetworkGetOpenseaAssetContract
	}

	if CurrentUidGetOpenseaAssetContractStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetOpenseaAssetContractStr := CurrentUidGetOpenseaAssetContractStrArr[0]
		CurrentUidGetOpenseaAssetContract, err := strconv.ParseUint(CurrentUidGetOpenseaAssetContractStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetOpenseaAssetContract from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetOpenseaAssetContract
	}

	return &req, err
}

// DecodeHTTPGetOpenseaAssetContractOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getopenseaassetcontract request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetOpenseaAssetContractOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetOpenseaAssetContractRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if AssetContractAddressGetOpenseaAssetContractStrArr, ok := queryParams["asset_contract_address"]; ok {
		AssetContractAddressGetOpenseaAssetContractStr := AssetContractAddressGetOpenseaAssetContractStrArr[0]
		AssetContractAddressGetOpenseaAssetContract := AssetContractAddressGetOpenseaAssetContractStr
		req.AssetContractAddress = AssetContractAddressGetOpenseaAssetContract
	}

	if TokenIdGetOpenseaAssetContractStrArr, ok := queryParams["token_id"]; ok {
		TokenIdGetOpenseaAssetContractStr := TokenIdGetOpenseaAssetContractStrArr[0]
		TokenIdGetOpenseaAssetContract := TokenIdGetOpenseaAssetContractStr
		req.TokenId = TokenIdGetOpenseaAssetContract
	}

	if AccountAddressGetOpenseaAssetContractStrArr, ok := queryParams["account_address"]; ok {
		AccountAddressGetOpenseaAssetContractStr := AccountAddressGetOpenseaAssetContractStrArr[0]
		AccountAddressGetOpenseaAssetContract := AccountAddressGetOpenseaAssetContractStr
		req.AccountAddress = AccountAddressGetOpenseaAssetContract
	}

	if IncludeOrdersGetOpenseaAssetContractStrArr, ok := queryParams["include_orders"]; ok {
		IncludeOrdersGetOpenseaAssetContractStr := IncludeOrdersGetOpenseaAssetContractStrArr[0]
		IncludeOrdersGetOpenseaAssetContract := IncludeOrdersGetOpenseaAssetContractStr
		req.IncludeOrders = IncludeOrdersGetOpenseaAssetContract
	}

	if NetworkGetOpenseaAssetContractStrArr, ok := queryParams["network"]; ok {
		NetworkGetOpenseaAssetContractStr := NetworkGetOpenseaAssetContractStrArr[0]
		NetworkGetOpenseaAssetContract := NetworkGetOpenseaAssetContractStr
		req.Network = NetworkGetOpenseaAssetContract
	}

	if CurrentUidGetOpenseaAssetContractStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetOpenseaAssetContractStr := CurrentUidGetOpenseaAssetContractStrArr[0]
		CurrentUidGetOpenseaAssetContract, err := strconv.ParseUint(CurrentUidGetOpenseaAssetContractStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetOpenseaAssetContract from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetOpenseaAssetContract
	}

	return &req, err
}

// DecodeHTTPPageNftAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageNftAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidPageNftAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidPageNftAssetStr := CurrentUidPageNftAssetStrArr[0]
		CurrentUidPageNftAsset, err := strconv.ParseUint(CurrentUidPageNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidPageNftAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidPageNftAsset
	}

	if UidPageNftAssetStrArr, ok := queryParams["uid"]; ok {
		UidPageNftAssetStr := UidPageNftAssetStrArr[0]
		UidPageNftAsset, err := strconv.ParseUint(UidPageNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidPageNftAsset from query, queryParams: %v", queryParams))
		}
		req.Uid = UidPageNftAsset
	}

	if PaginatorPageNftAssetStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageNftAssetStr := PaginatorPageNftAssetStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageNftAssetStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageNftAsset from %v", PaginatorPageNftAssetStr)
		}

	}

	if SortByPageNftAssetStrArr, ok := queryParams["sort_by"]; ok {
		SortByPageNftAssetStr := SortByPageNftAssetStrArr[0]
		SortByPageNftAsset := SortByPageNftAssetStr
		req.SortBy = SortByPageNftAsset
	}

	if ScenePageNftAssetStrArr, ok := queryParams["scene"]; ok {
		ScenePageNftAssetStr := ScenePageNftAssetStrArr[0]
		ScenePageNftAsset := ScenePageNftAssetStr
		req.Scene = ScenePageNftAsset
	}

	return &req, err
}

// DecodeHTTPPageNftAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagenftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageNftAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidPageNftAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidPageNftAssetStr := CurrentUidPageNftAssetStrArr[0]
		CurrentUidPageNftAsset, err := strconv.ParseUint(CurrentUidPageNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidPageNftAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidPageNftAsset
	}

	if UidPageNftAssetStrArr, ok := queryParams["uid"]; ok {
		UidPageNftAssetStr := UidPageNftAssetStrArr[0]
		UidPageNftAsset, err := strconv.ParseUint(UidPageNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidPageNftAsset from query, queryParams: %v", queryParams))
		}
		req.Uid = UidPageNftAsset
	}

	if PaginatorPageNftAssetStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageNftAssetStr := PaginatorPageNftAssetStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageNftAssetStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageNftAsset from %v", PaginatorPageNftAssetStr)
		}

	}

	if SortByPageNftAssetStrArr, ok := queryParams["sort_by"]; ok {
		SortByPageNftAssetStr := SortByPageNftAssetStrArr[0]
		SortByPageNftAsset := SortByPageNftAssetStr
		req.SortBy = SortByPageNftAsset
	}

	if ScenePageNftAssetStrArr, ok := queryParams["scene"]; ok {
		ScenePageNftAssetStr := ScenePageNftAssetStrArr[0]
		ScenePageNftAsset := ScenePageNftAssetStr
		req.Scene = ScenePageNftAsset
	}

	return &req, err
}

// DecodeHTTPGetNftAssetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getnftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetNftAssetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetNftAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetNftAssetStr := CurrentUidGetNftAssetStrArr[0]
		CurrentUidGetNftAsset, err := strconv.ParseUint(CurrentUidGetNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetNftAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetNftAsset
	}

	if NftAssetIdGetNftAssetStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdGetNftAssetStr := NftAssetIdGetNftAssetStrArr[0]
		NftAssetIdGetNftAsset := NftAssetIdGetNftAssetStr
		req.NftAssetId = NftAssetIdGetNftAsset
	}

	return &req, err
}

// DecodeHTTPGetNftAssetOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getnftasset request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetNftAssetOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetNftAssetRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetNftAssetStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetNftAssetStr := CurrentUidGetNftAssetStrArr[0]
		CurrentUidGetNftAsset, err := strconv.ParseUint(CurrentUidGetNftAssetStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetNftAsset from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetNftAsset
	}

	if NftAssetIdGetNftAssetStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdGetNftAssetStr := NftAssetIdGetNftAssetStrArr[0]
		NftAssetIdGetNftAsset := NftAssetIdGetNftAssetStr
		req.NftAssetId = NftAssetIdGetNftAsset
	}

	return &req, err
}

// DecodeHTTPPageNftEventZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagenftevent request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageNftEventZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageNftEventRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidPageNftEventStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidPageNftEventStr := CurrentUidPageNftEventStrArr[0]
		CurrentUidPageNftEvent, err := strconv.ParseUint(CurrentUidPageNftEventStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidPageNftEvent from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidPageNftEvent
	}

	if NftAssetIdPageNftEventStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdPageNftEventStr := NftAssetIdPageNftEventStrArr[0]
		NftAssetIdPageNftEvent := NftAssetIdPageNftEventStr
		req.NftAssetId = NftAssetIdPageNftEvent
	}

	if PaginatorPageNftEventStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageNftEventStr := PaginatorPageNftEventStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageNftEventStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageNftEvent from %v", PaginatorPageNftEventStr)
		}

	}

	return &req, err
}

// DecodeHTTPPageNftEventOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded pagenftevent request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPageNftEventOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PageNftEventRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidPageNftEventStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidPageNftEventStr := CurrentUidPageNftEventStrArr[0]
		CurrentUidPageNftEvent, err := strconv.ParseUint(CurrentUidPageNftEventStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidPageNftEvent from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidPageNftEvent
	}

	if NftAssetIdPageNftEventStrArr, ok := queryParams["nft_asset_id"]; ok {
		NftAssetIdPageNftEventStr := NftAssetIdPageNftEventStrArr[0]
		NftAssetIdPageNftEvent := NftAssetIdPageNftEventStr
		req.NftAssetId = NftAssetIdPageNftEvent
	}

	if PaginatorPageNftEventStrArr, ok := queryParams["paginator"]; ok {
		PaginatorPageNftEventStr := PaginatorPageNftEventStrArr[0]

		err = json.Unmarshal([]byte(PaginatorPageNftEventStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorPageNftEvent from %v", PaginatorPageNftEventStr)
		}

	}

	return &req, err
}

// DecodeHTTPUpdateUserConfigZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserconfig request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserConfigZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserConfigRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateUserConfigOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateuserconfig request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateUserConfigOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateUserConfigRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPComplaintZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded complaint request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPComplaintZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ComplaintRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPComplaintOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded complaint request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPComplaintOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ComplaintRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPGetUserConfigZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getuserconfig request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetUserConfigZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetUserConfigRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetUserConfigStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetUserConfigStr := CurrentUidGetUserConfigStrArr[0]
		CurrentUidGetUserConfig, err := strconv.ParseUint(CurrentUidGetUserConfigStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetUserConfig from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetUserConfig
	}

	if UidGetUserConfigStrArr, ok := queryParams["uid"]; ok {
		UidGetUserConfigStr := UidGetUserConfigStrArr[0]
		UidGetUserConfig, err := strconv.ParseUint(UidGetUserConfigStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidGetUserConfig from query, queryParams: %v", queryParams))
		}
		req.Uid = UidGetUserConfig
	}

	return &req, err
}

// DecodeHTTPGetUserConfigOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getuserconfig request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetUserConfigOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetUserConfigRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetUserConfigStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetUserConfigStr := CurrentUidGetUserConfigStrArr[0]
		CurrentUidGetUserConfig, err := strconv.ParseUint(CurrentUidGetUserConfigStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetUserConfig from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetUserConfig
	}

	if UidGetUserConfigStrArr, ok := queryParams["uid"]; ok {
		UidGetUserConfigStr := UidGetUserConfigStrArr[0]
		UidGetUserConfig, err := strconv.ParseUint(UidGetUserConfigStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting UidGetUserConfig from query, queryParams: %v", queryParams))
		}
		req.Uid = UidGetUserConfig
	}

	return &req, err
}

// DecodeHTTPUpdateOpenseaNftZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateopenseanft request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateOpenseaNftZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateOpenseaNftRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPUpdateOpenseaNftOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded updateopenseanft request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateOpenseaNftOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.UpdateOpenseaNftRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPGetTwitterAuthUrlZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded gettwitterauthurl request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetTwitterAuthUrlZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetTwitterAuthUrlRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetTwitterAuthUrlStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetTwitterAuthUrlStr := CurrentUidGetTwitterAuthUrlStrArr[0]
		CurrentUidGetTwitterAuthUrl, err := strconv.ParseUint(CurrentUidGetTwitterAuthUrlStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetTwitterAuthUrl from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetTwitterAuthUrl
	}

	return &req, err
}

// DecodeHTTPGetTwitterAuthUrlOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded gettwitterauthurl request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetTwitterAuthUrlOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetTwitterAuthUrlRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetTwitterAuthUrlStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetTwitterAuthUrlStr := CurrentUidGetTwitterAuthUrlStrArr[0]
		CurrentUidGetTwitterAuthUrl, err := strconv.ParseUint(CurrentUidGetTwitterAuthUrlStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetTwitterAuthUrl from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetTwitterAuthUrl
	}

	return &req, err
}

// DecodeHTTPGetAirdropInfoZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getairdropinfo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetAirdropInfoZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetAirdropInfoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetAirdropInfoStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetAirdropInfoStr := CurrentUidGetAirdropInfoStrArr[0]
		CurrentUidGetAirdropInfo, err := strconv.ParseUint(CurrentUidGetAirdropInfoStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetAirdropInfo from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetAirdropInfo
	}

	return &req, err
}

// DecodeHTTPGetAirdropInfoOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getairdropinfo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetAirdropInfoOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetAirdropInfoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidGetAirdropInfoStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidGetAirdropInfoStr := CurrentUidGetAirdropInfoStrArr[0]
		CurrentUidGetAirdropInfo, err := strconv.ParseUint(CurrentUidGetAirdropInfoStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidGetAirdropInfo from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidGetAirdropInfo
	}

	return &req, err
}

// DecodeHTTPTwitterCallbackZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twittercallback request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterCallbackZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterCallbackRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidTwitterCallbackStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidTwitterCallbackStr := CurrentUidTwitterCallbackStrArr[0]
		CurrentUidTwitterCallback, err := strconv.ParseUint(CurrentUidTwitterCallbackStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidTwitterCallback from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidTwitterCallback
	}

	if OauthTokenTwitterCallbackStrArr, ok := queryParams["oauth_token"]; ok {
		OauthTokenTwitterCallbackStr := OauthTokenTwitterCallbackStrArr[0]
		OauthTokenTwitterCallback := OauthTokenTwitterCallbackStr
		req.OauthToken = OauthTokenTwitterCallback
	}

	if OauthVerifierTwitterCallbackStrArr, ok := queryParams["oauth_verifier"]; ok {
		OauthVerifierTwitterCallbackStr := OauthVerifierTwitterCallbackStrArr[0]
		OauthVerifierTwitterCallback := OauthVerifierTwitterCallbackStr
		req.OauthVerifier = OauthVerifierTwitterCallback
	}

	return &req, err
}

// DecodeHTTPTwitterCallbackOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twittercallback request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterCallbackOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterCallbackRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidTwitterCallbackStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidTwitterCallbackStr := CurrentUidTwitterCallbackStrArr[0]
		CurrentUidTwitterCallback, err := strconv.ParseUint(CurrentUidTwitterCallbackStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidTwitterCallback from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidTwitterCallback
	}

	if OauthTokenTwitterCallbackStrArr, ok := queryParams["oauth_token"]; ok {
		OauthTokenTwitterCallbackStr := OauthTokenTwitterCallbackStrArr[0]
		OauthTokenTwitterCallback := OauthTokenTwitterCallbackStr
		req.OauthToken = OauthTokenTwitterCallback
	}

	if OauthVerifierTwitterCallbackStrArr, ok := queryParams["oauth_verifier"]; ok {
		OauthVerifierTwitterCallbackStr := OauthVerifierTwitterCallbackStrArr[0]
		OauthVerifierTwitterCallback := OauthVerifierTwitterCallbackStr
		req.OauthVerifier = OauthVerifierTwitterCallback
	}

	return &req, err
}

// DecodeHTTPTwitterFollowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twitterfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterFollowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPTwitterFollowOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded twitterfollow request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTwitterFollowOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TwitterFollowRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPReceiveAirdropZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded receiveairdrop request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReceiveAirdropZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReceiveAirdropRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidReceiveAirdropStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidReceiveAirdropStr := CurrentUidReceiveAirdropStrArr[0]
		CurrentUidReceiveAirdrop, err := strconv.ParseUint(CurrentUidReceiveAirdropStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidReceiveAirdrop from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidReceiveAirdrop
	}

	if TweetReceiveAirdropStrArr, ok := queryParams["tweet"]; ok {
		TweetReceiveAirdropStr := TweetReceiveAirdropStrArr[0]
		TweetReceiveAirdrop := TweetReceiveAirdropStr
		req.Tweet = TweetReceiveAirdrop
	}

	return &req, err
}

// DecodeHTTPReceiveAirdropOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded receiveairdrop request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReceiveAirdropOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReceiveAirdropRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CurrentUidReceiveAirdropStrArr, ok := queryParams["current_uid"]; ok {
		CurrentUidReceiveAirdropStr := CurrentUidReceiveAirdropStrArr[0]
		CurrentUidReceiveAirdrop, err := strconv.ParseUint(CurrentUidReceiveAirdropStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting CurrentUidReceiveAirdrop from query, queryParams: %v", queryParams))
		}
		req.CurrentUid = CurrentUidReceiveAirdrop
	}

	if TweetReceiveAirdropStrArr, ok := queryParams["tweet"]; ok {
		TweetReceiveAirdropStr := TweetReceiveAirdropStrArr[0]
		TweetReceiveAirdrop := TweetReceiveAirdropStr
		req.Tweet = TweetReceiveAirdrop
	}

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: false,
		OrigName:     true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

// encodePathParams encodes `mux.Vars()` with dot notations into JSON objects
// to be unmarshaled into non-basetype fields.
// e.g. {"book.name": "books/1"} -> {"book": {"name": "books/1"}}
func encodePathParams(vars map[string]string) map[string]string {
	var recur func(path, value string, data map[string]interface{})
	recur = func(path, value string, data map[string]interface{}) {
		parts := strings.SplitN(path, ".", 2)
		key := parts[0]
		if len(parts) == 1 {
			data[key] = value
		} else {
			if _, ok := data[key]; !ok {
				data[key] = make(map[string]interface{})
			}
			recur(parts[1], value, data[key].(map[string]interface{}))
		}
	}

	data := make(map[string]interface{})
	for key, val := range vars {
		recur(key, val, data)
	}

	ret := make(map[string]string)
	for key, val := range data {
		switch val := val.(type) {
		case string:
			ret[key] = val
		case map[string]interface{}:
			m, _ := json.Marshal(val)
			ret[key] = string(m)
		}
	}
	return ret
}
